

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sqlalchemy.orm.session &mdash; BenchBuild - Empirical Research Toolkit 1.3.2 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../../genindex.html"/>
        <link rel="search" title="Search" href="../../../search.html"/>
    <link rel="top" title="BenchBuild - Empirical Research Toolkit 1.3.2 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> BenchBuild - Empirical Research Toolkit
          

          
          </a>

          
            
            
              <div class="version">
                1.3.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../benchbuild.html">benchbuild package</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">BenchBuild - Empirical Research Toolkit</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>sqlalchemy.orm.session</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sqlalchemy.orm.session</h1><div class="highlight"><pre>
<span></span><span class="c1"># orm/session.py</span>
<span class="c1"># Copyright (C) 2005-2015 the SQLAlchemy authors and contributors</span>
<span class="c1"># &lt;see AUTHORS file&gt;</span>
<span class="c1">#</span>
<span class="c1"># This module is part of SQLAlchemy and is released under</span>
<span class="c1"># the MIT License: http://www.opensource.org/licenses/mit-license.php</span>
<span class="sd">&quot;&quot;&quot;Provides the Session class and related utilities.&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="k">import</span> <span class="n">util</span><span class="p">,</span> <span class="n">sql</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="n">exc</span> <span class="k">as</span> <span class="n">sa_exc</span>
<span class="kn">from</span> <span class="nn">..sql</span> <span class="k">import</span> <span class="n">util</span> <span class="k">as</span> <span class="n">sql_util</span><span class="p">,</span> <span class="n">expression</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">SessionExtension</span><span class="p">,</span> <span class="n">attributes</span><span class="p">,</span> <span class="n">exc</span><span class="p">,</span> <span class="n">query</span><span class="p">,</span>
    <span class="n">loading</span><span class="p">,</span> <span class="n">identity</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">..inspection</span> <span class="k">import</span> <span class="n">inspect</span>
<span class="kn">from</span> <span class="nn">.base</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">object_mapper</span><span class="p">,</span> <span class="n">class_mapper</span><span class="p">,</span>
    <span class="n">_class_to_mapper</span><span class="p">,</span> <span class="n">_state_mapper</span><span class="p">,</span> <span class="n">object_state</span><span class="p">,</span>
    <span class="n">_none_set</span><span class="p">,</span> <span class="n">state_str</span><span class="p">,</span> <span class="n">instance_str</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">persistence</span>
<span class="kn">from</span> <span class="nn">.unitofwork</span> <span class="k">import</span> <span class="n">UOWTransaction</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">state</span> <span class="k">as</span> <span class="n">statelib</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Session&#39;</span><span class="p">,</span> <span class="s1">&#39;SessionTransaction&#39;</span><span class="p">,</span>
           <span class="s1">&#39;SessionExtension&#39;</span><span class="p">,</span> <span class="s1">&#39;sessionmaker&#39;</span><span class="p">]</span>

<span class="n">_sessions</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakValueDictionary</span><span class="p">()</span>
<span class="sd">&quot;&quot;&quot;Weak-referencing dictionary of :class:`.Session` objects.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_state_session</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Given an :class:`.InstanceState`, return the :class:`.Session`</span>
<span class="sd">        associated, if any.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_sessions</span><span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">session_id</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">_SessionClassMethods</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class-level methods for :class:`.Session`, :class:`.sessionmaker`.&quot;&quot;&quot;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">close_all</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close *all* sessions in memory.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">sess</span> <span class="ow">in</span> <span class="n">_sessions</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">sess</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="nd">@util</span><span class="o">.</span><span class="n">dependencies</span><span class="p">(</span><span class="s2">&quot;sqlalchemy.orm.util&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">identity_key</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">orm_util</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an identity key.</span>

<span class="sd">        This is an alias of :func:`.util.identity_key`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">orm_util</span><span class="o">.</span><span class="n">identity_key</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">object_session</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the :class:`.Session` to which an object belongs.</span>

<span class="sd">        This is an alias of :func:`.object_session`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">object_session</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>


<span class="n">ACTIVE</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s1">&#39;ACTIVE&#39;</span><span class="p">)</span>
<span class="n">PREPARED</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s1">&#39;PREPARED&#39;</span><span class="p">)</span>
<span class="n">COMMITTED</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s1">&#39;COMMITTED&#39;</span><span class="p">)</span>
<span class="n">DEACTIVE</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s1">&#39;DEACTIVE&#39;</span><span class="p">)</span>
<span class="n">CLOSED</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">symbol</span><span class="p">(</span><span class="s1">&#39;CLOSED&#39;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">SessionTransaction</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A :class:`.Session`-level transaction.</span>

<span class="sd">    :class:`.SessionTransaction` is a mostly behind-the-scenes object</span>
<span class="sd">    not normally referenced directly by application code.   It coordinates</span>
<span class="sd">    among multiple :class:`.Connection` objects, maintaining a database</span>
<span class="sd">    transaction for each one individually, committing or rolling them</span>
<span class="sd">    back all at once.   It also provides optional two-phase commit behavior</span>
<span class="sd">    which can augment this coordination operation.</span>

<span class="sd">    The :attr:`.Session.transaction` attribute of :class:`.Session`</span>
<span class="sd">    refers to the current :class:`.SessionTransaction` object in use, if any.</span>


<span class="sd">    A :class:`.SessionTransaction` is associated with a :class:`.Session`</span>
<span class="sd">    in its default mode of ``autocommit=False`` immediately, associated</span>
<span class="sd">    with no database connections.  As the :class:`.Session` is called upon</span>
<span class="sd">    to emit SQL on behalf of various :class:`.Engine` or :class:`.Connection`</span>
<span class="sd">    objects, a corresponding :class:`.Connection` and associated</span>
<span class="sd">    :class:`.Transaction` is added to a collection within the</span>
<span class="sd">    :class:`.SessionTransaction` object, becoming one of the</span>
<span class="sd">    connection/transaction pairs maintained by the</span>
<span class="sd">    :class:`.SessionTransaction`.</span>

<span class="sd">    The lifespan of the :class:`.SessionTransaction` ends when the</span>
<span class="sd">    :meth:`.Session.commit`, :meth:`.Session.rollback` or</span>
<span class="sd">    :meth:`.Session.close` methods are called.  At this point, the</span>
<span class="sd">    :class:`.SessionTransaction` removes its association with its parent</span>
<span class="sd">    :class:`.Session`.   A :class:`.Session` that is in ``autocommit=False``</span>
<span class="sd">    mode will create a new :class:`.SessionTransaction` to replace it</span>
<span class="sd">    immediately, whereas a :class:`.Session` that&#39;s in ``autocommit=True``</span>
<span class="sd">    mode will remain without a :class:`.SessionTransaction` until the</span>
<span class="sd">    :meth:`.Session.begin` method is called.</span>

<span class="sd">    Another detail of :class:`.SessionTransaction` behavior is that it is</span>
<span class="sd">    capable of &quot;nesting&quot;.  This means that the :meth:`.Session.begin` method</span>
<span class="sd">    can be called while an existing :class:`.SessionTransaction` is already</span>
<span class="sd">    present, producing a new :class:`.SessionTransaction` that temporarily</span>
<span class="sd">    replaces the parent :class:`.SessionTransaction`.   When a</span>
<span class="sd">    :class:`.SessionTransaction` is produced as nested, it assigns itself to</span>
<span class="sd">    the :attr:`.Session.transaction` attribute.  When it is ended via</span>
<span class="sd">    :meth:`.Session.commit` or :meth:`.Session.rollback`, it restores its</span>
<span class="sd">    parent :class:`.SessionTransaction` back onto the</span>
<span class="sd">    :attr:`.Session.transaction` attribute.  The behavior is effectively a</span>
<span class="sd">    stack, where :attr:`.Session.transaction` refers to the current head of</span>
<span class="sd">    the stack.</span>

<span class="sd">    The purpose of this stack is to allow nesting of</span>
<span class="sd">    :meth:`.Session.rollback` or :meth:`.Session.commit` calls in context</span>
<span class="sd">    with various flavors of :meth:`.Session.begin`. This nesting behavior</span>
<span class="sd">    applies to when :meth:`.Session.begin_nested` is used to emit a</span>
<span class="sd">    SAVEPOINT transaction, and is also used to produce a so-called</span>
<span class="sd">    &quot;subtransaction&quot; which allows a block of code to use a</span>
<span class="sd">    begin/rollback/commit sequence regardless of whether or not its enclosing</span>
<span class="sd">    code block has begun a transaction.  The :meth:`.flush` method, whether</span>
<span class="sd">    called explicitly or via autoflush, is the primary consumer of the</span>
<span class="sd">    &quot;subtransaction&quot; feature, in that it wishes to guarantee that it works</span>
<span class="sd">    within in a transaction block regardless of whether or not the</span>
<span class="sd">    :class:`.Session` is in transactional mode when the method is called.</span>

<span class="sd">    See also:</span>

<span class="sd">    :meth:`.Session.rollback`</span>

<span class="sd">    :meth:`.Session.commit`</span>

<span class="sd">    :meth:`.Session.begin`</span>

<span class="sd">    :meth:`.Session.begin_nested`</span>

<span class="sd">    :attr:`.Session.is_active`</span>

<span class="sd">    :meth:`.SessionEvents.after_commit`</span>

<span class="sd">    :meth:`.SessionEvents.after_rollback`</span>

<span class="sd">    :meth:`.SessionEvents.after_soft_rollback`</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_rollback_exception</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="n">session</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nested</span> <span class="o">=</span> <span class="n">nested</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">ACTIVE</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">parent</span> <span class="ow">and</span> <span class="n">nested</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t start a SAVEPOINT transaction when no existing &quot;</span>
                <span class="s2">&quot;transaction is in progress&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_take_snapshot</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_transaction_create</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_transaction_create</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_active</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">ACTIVE</span>

    <span class="k">def</span> <span class="nf">_assert_active</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prepared_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">rollback_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">deactive_ok</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">closed_msg</span><span class="o">=</span><span class="s2">&quot;This transaction is closed&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">COMMITTED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;This session is in &#39;committed&#39; state; no further &quot;</span>
                <span class="s2">&quot;SQL can be emitted within this transaction.&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">PREPARED</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">prepared_ok</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;This session is in &#39;prepared&#39; state; no further &quot;</span>
                    <span class="s2">&quot;SQL can be emitted within this transaction.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">DEACTIVE</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">deactive_ok</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">rollback_ok</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rollback_exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                        <span class="s2">&quot;This Session&#39;s transaction has been rolled back &quot;</span>
                        <span class="s2">&quot;due to a previous exception during flush.&quot;</span>
                        <span class="s2">&quot; To begin a new transaction with this Session, &quot;</span>
                        <span class="s2">&quot;first issue Session.rollback().&quot;</span>
                        <span class="s2">&quot; Original exception was: </span><span class="si">%s</span><span class="s2">&quot;</span>
                        <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rollback_exception</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">deactive_ok</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                        <span class="s2">&quot;This Session&#39;s transaction has been rolled back &quot;</span>
                        <span class="s2">&quot;by a nested rollback() call.  To begin a new &quot;</span>
                        <span class="s2">&quot;transaction, issue Session.rollback() first.&quot;</span>
                    <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="n">CLOSED</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">ResourceClosedError</span><span class="p">(</span><span class="n">closed_msg</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_is_transaction_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

    <span class="k">def</span> <span class="nf">connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindkey</span><span class="p">,</span> <span class="n">execution_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">()</span>
        <span class="n">bind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">get_bind</span><span class="p">(</span><span class="n">bindkey</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">execution_options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_begin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">SessionTransaction</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_iterate_parents</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">upto</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">while</span> <span class="n">current</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="n">upto</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">current</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;Transaction </span><span class="si">%s</span><span class="s2"> is not on the active transaction list&quot;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">upto</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">_parent</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_take_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transaction_boundary</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_new</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_deleted</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_dirty</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_key_switches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_key_switches</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_flushing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_key_switches</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">WeakKeyDictionary</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_restore_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirty_only</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transaction_boundary</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_new</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_expunge_state</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">s</span><span class="o">.</span><span class="n">key</span>

        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">oldkey</span><span class="p">,</span> <span class="n">newkey</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_key_switches</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">safe_discard</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">oldkey</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_deleted</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">deleted</span><span class="p">:</span>
                <span class="c1"># assert s in self._deleted</span>
                <span class="k">del</span> <span class="n">s</span><span class="o">.</span><span class="n">deleted</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_update_impl</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">discard_existing</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_deleted</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">all_states</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dirty_only</span> <span class="ow">or</span> <span class="n">s</span><span class="o">.</span><span class="n">modified</span> <span class="ow">or</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">:</span>
                <span class="n">s</span><span class="o">.</span><span class="n">_expire</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remove_snapshot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_transaction_boundary</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">expire_on_commit</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">all_states</span><span class="p">():</span>
                <span class="n">s</span><span class="o">.</span><span class="n">_expire</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">):</span>
                <span class="n">s</span><span class="o">.</span><span class="n">_detach</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_dirty</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dirty</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_key_switches</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_key_switches</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_connection_for_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bind</span><span class="p">,</span> <span class="n">execution_options</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">bind</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">execution_options</span><span class="p">:</span>
                <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Connection is already established for the &quot;</span>
                    <span class="s2">&quot;given bind; execution_options ignored&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">[</span><span class="n">bind</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">execution_options</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">conn</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span> <span class="n">engine</span><span class="o">.</span><span class="n">Connection</span><span class="p">):</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="n">bind</span>
                <span class="k">if</span> <span class="n">conn</span><span class="o">.</span><span class="n">engine</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                        <span class="s2">&quot;Session already has a Connection associated for the &quot;</span>
                        <span class="s2">&quot;given Connection&#39;s Engine&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="n">bind</span><span class="o">.</span><span class="n">contextual_connect</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">execution_options</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="o">**</span><span class="n">execution_options</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">twophase</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transaction</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin_twophase</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
            <span class="n">transaction</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin_nested</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">transaction</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">[</span><span class="n">conn</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="p">[</span><span class="n">conn</span><span class="o">.</span><span class="n">engine</span><span class="p">]</span> <span class="o">=</span> \
            <span class="p">(</span><span class="n">conn</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">conn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">bind</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_begin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">conn</span>

    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">twophase</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;twophase&#39; mode not enabled, or not root transaction; &quot;</span>
                <span class="s2">&quot;can&#39;t prepare.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_impl</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_prepare_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_commit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>

        <span class="n">stx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">transaction</span>
        <span class="k">if</span> <span class="n">stx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subtransaction</span> <span class="ow">in</span> <span class="n">stx</span><span class="o">.</span><span class="n">_iterate_parents</span><span class="p">(</span><span class="n">upto</span><span class="o">=</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">subtransaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_flushing</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_flush_guard</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_is_clean</span><span class="p">():</span>
                    <span class="k">break</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">FlushError</span><span class="p">(</span>
                    <span class="s2">&quot;Over 100 subsequent flushes have occurred within &quot;</span>
                    <span class="s2">&quot;session.commit() - is an after_flush() hook &quot;</span>
                    <span class="s2">&quot;creating new objects?&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">twophase</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                    <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">PREPARED</span>

    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">(</span><span class="n">prepared_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">PREPARED</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_impl</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">COMMITTED</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_commit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_remove_snapshot</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

    <span class="k">def</span> <span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_capture_exception</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">(</span><span class="n">prepared_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rollback_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">stx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">transaction</span>
        <span class="k">if</span> <span class="n">stx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">subtransaction</span> <span class="ow">in</span> <span class="n">stx</span><span class="o">.</span><span class="n">_iterate_parents</span><span class="p">(</span><span class="n">upto</span><span class="o">=</span><span class="bp">self</span><span class="p">):</span>
                <span class="n">subtransaction</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">boundary</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="ow">in</span> <span class="p">(</span><span class="n">ACTIVE</span><span class="p">,</span> <span class="n">PREPARED</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">transaction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iterate_parents</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">transaction</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">transaction</span><span class="o">.</span><span class="n">nested</span><span class="p">:</span>
                    <span class="n">transaction</span><span class="o">.</span><span class="n">_rollback_impl</span><span class="p">()</span>
                    <span class="n">transaction</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">DEACTIVE</span>
                    <span class="n">boundary</span> <span class="o">=</span> <span class="n">transaction</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">transaction</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">DEACTIVE</span>

        <span class="n">sess</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span>

        <span class="k">if</span> <span class="n">sess</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="n">sess</span><span class="o">.</span><span class="n">_is_clean</span><span class="p">():</span>

            <span class="c1"># if items were added, deleted, or mutated</span>
            <span class="c1"># here, we need to re-restore the snapshot</span>
            <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Session&#39;s state has been changed on &quot;</span>
                <span class="s2">&quot;a non-active transaction - this state &quot;</span>
                <span class="s2">&quot;will be discarded.&quot;</span><span class="p">)</span>
            <span class="n">boundary</span><span class="o">.</span><span class="n">_restore_snapshot</span><span class="p">(</span><span class="n">dirty_only</span><span class="o">=</span><span class="n">boundary</span><span class="o">.</span><span class="n">nested</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">and</span> <span class="n">_capture_exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_rollback_exception</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">sess</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_soft_rollback</span><span class="p">(</span><span class="n">sess</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>

    <span class="k">def</span> <span class="nf">_rollback_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_restore_snapshot</span><span class="p">(</span><span class="n">dirty_only</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nested</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_rollback</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invalidate</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">transaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">connection</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">autoclose</span> <span class="ow">in</span> \
                    <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_connections</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">invalidate</span><span class="p">:</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">autoclose</span><span class="p">:</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">transaction</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="n">CLOSED</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_transaction_end</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_transaction_end</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">autocommit</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">session</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_connections</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_assert_active</span><span class="p">(</span><span class="n">deactive_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">prepared_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>


<span class="k">class</span> <span class="nc">Session</span><span class="p">(</span><span class="n">_SessionClassMethods</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Manages persistence operations for ORM-mapped objects.</span>

<span class="sd">    The Session&#39;s usage paradigm is described at :doc:`/orm/session`.</span>


<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">public_methods</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;__contains__&#39;</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="s1">&#39;add_all&#39;</span><span class="p">,</span> <span class="s1">&#39;begin&#39;</span><span class="p">,</span> <span class="s1">&#39;begin_nested&#39;</span><span class="p">,</span>
        <span class="s1">&#39;close&#39;</span><span class="p">,</span> <span class="s1">&#39;commit&#39;</span><span class="p">,</span> <span class="s1">&#39;connection&#39;</span><span class="p">,</span> <span class="s1">&#39;delete&#39;</span><span class="p">,</span> <span class="s1">&#39;execute&#39;</span><span class="p">,</span> <span class="s1">&#39;expire&#39;</span><span class="p">,</span>
        <span class="s1">&#39;expire_all&#39;</span><span class="p">,</span> <span class="s1">&#39;expunge&#39;</span><span class="p">,</span> <span class="s1">&#39;expunge_all&#39;</span><span class="p">,</span> <span class="s1">&#39;flush&#39;</span><span class="p">,</span> <span class="s1">&#39;get_bind&#39;</span><span class="p">,</span>
        <span class="s1">&#39;is_modified&#39;</span><span class="p">,</span> <span class="s1">&#39;bulk_save_objects&#39;</span><span class="p">,</span> <span class="s1">&#39;bulk_insert_mappings&#39;</span><span class="p">,</span>
        <span class="s1">&#39;bulk_update_mappings&#39;</span><span class="p">,</span>
        <span class="s1">&#39;merge&#39;</span><span class="p">,</span> <span class="s1">&#39;query&#39;</span><span class="p">,</span> <span class="s1">&#39;refresh&#39;</span><span class="p">,</span> <span class="s1">&#39;rollback&#39;</span><span class="p">,</span>
        <span class="s1">&#39;scalar&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">autoflush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">expire_on_commit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">_enable_transaction_accounting</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">autocommit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">twophase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">weak_identity_map</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">binds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">query_cls</span><span class="o">=</span><span class="n">query</span><span class="o">.</span><span class="n">Query</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a new Session.</span>

<span class="sd">        See also the :class:`.sessionmaker` function which is used to</span>
<span class="sd">        generate a :class:`.Session`-producing callable with a given</span>
<span class="sd">        set of arguments.</span>

<span class="sd">        :param autocommit:</span>

<span class="sd">          .. warning::</span>

<span class="sd">             The autocommit flag is **not for general use**, and if it is</span>
<span class="sd">             used, queries should only be invoked within the span of a</span>
<span class="sd">             :meth:`.Session.begin` / :meth:`.Session.commit` pair.  Executing</span>
<span class="sd">             queries outside of a demarcated transaction is a legacy mode</span>
<span class="sd">             of usage, and can in some cases lead to concurrent connection</span>
<span class="sd">             checkouts.</span>

<span class="sd">          Defaults to ``False``. When ``True``, the</span>
<span class="sd">          :class:`.Session` does not keep a persistent transaction running,</span>
<span class="sd">          and will acquire connections from the engine on an as-needed basis,</span>
<span class="sd">          returning them immediately after their use. Flushes will begin and</span>
<span class="sd">          commit (or possibly rollback) their own transaction if no</span>
<span class="sd">          transaction is present. When using this mode, the</span>
<span class="sd">          :meth:`.Session.begin` method is used to explicitly start</span>
<span class="sd">          transactions.</span>

<span class="sd">          .. seealso::</span>

<span class="sd">            :ref:`session_autocommit`</span>

<span class="sd">        :param autoflush: When ``True``, all query operations will issue a</span>
<span class="sd">           :meth:`~.Session.flush` call to this ``Session`` before proceeding.</span>
<span class="sd">           This is a convenience feature so that :meth:`~.Session.flush` need</span>
<span class="sd">           not be called repeatedly in order for database queries to retrieve</span>
<span class="sd">           results. It&#39;s typical that ``autoflush`` is used in conjunction</span>
<span class="sd">           with ``autocommit=False``. In this scenario, explicit calls to</span>
<span class="sd">           :meth:`~.Session.flush` are rarely needed; you usually only need to</span>
<span class="sd">           call :meth:`~.Session.commit` (which flushes) to finalize changes.</span>

<span class="sd">        :param bind: An optional :class:`.Engine` or :class:`.Connection` to</span>
<span class="sd">           which this ``Session`` should be bound. When specified, all SQL</span>
<span class="sd">           operations performed by this session will execute via this</span>
<span class="sd">           connectable.</span>

<span class="sd">        :param binds: An optional dictionary which contains more granular</span>
<span class="sd">           &quot;bind&quot; information than the ``bind`` parameter provides. This</span>
<span class="sd">           dictionary can map individual :class`.Table`</span>
<span class="sd">           instances as well as :class:`~.Mapper` instances to individual</span>
<span class="sd">           :class:`.Engine` or :class:`.Connection` objects. Operations which</span>
<span class="sd">           proceed relative to a particular :class:`.Mapper` will consult this</span>
<span class="sd">           dictionary for the direct :class:`.Mapper` instance as</span>
<span class="sd">           well as the mapper&#39;s ``mapped_table`` attribute in order to locate</span>
<span class="sd">           a connectable to use. The full resolution is described in the</span>
<span class="sd">           :meth:`.Session.get_bind`.</span>
<span class="sd">           Usage looks like::</span>

<span class="sd">            Session = sessionmaker(binds={</span>
<span class="sd">                SomeMappedClass: create_engine(&#39;postgresql://engine1&#39;),</span>
<span class="sd">                somemapper: create_engine(&#39;postgresql://engine2&#39;),</span>
<span class="sd">                some_table: create_engine(&#39;postgresql://engine3&#39;),</span>
<span class="sd">                })</span>

<span class="sd">          Also see the :meth:`.Session.bind_mapper`</span>
<span class="sd">          and :meth:`.Session.bind_table` methods.</span>

<span class="sd">        :param \class_: Specify an alternate class other than</span>
<span class="sd">           ``sqlalchemy.orm.session.Session`` which should be used by the</span>
<span class="sd">           returned class. This is the only argument that is local to the</span>
<span class="sd">           :class:`.sessionmaker` function, and is not sent directly to the</span>
<span class="sd">           constructor for ``Session``.</span>

<span class="sd">        :param _enable_transaction_accounting:  Defaults to ``True``.  A</span>
<span class="sd">           legacy-only flag which when ``False`` disables *all* 0.5-style</span>
<span class="sd">           object accounting on transaction boundaries, including auto-expiry</span>
<span class="sd">           of instances on rollback and commit, maintenance of the &quot;new&quot; and</span>
<span class="sd">           &quot;deleted&quot; lists upon rollback, and autoflush of pending changes</span>
<span class="sd">           upon :meth:`~.Session.begin`, all of which are interdependent.</span>

<span class="sd">        :param expire_on_commit:  Defaults to ``True``. When ``True``, all</span>
<span class="sd">           instances will be fully expired after each :meth:`~.commit`,</span>
<span class="sd">           so that all attribute/object access subsequent to a completed</span>
<span class="sd">           transaction will load from the most recent database state.</span>

<span class="sd">        :param extension: An optional</span>
<span class="sd">           :class:`~.SessionExtension` instance, or a list</span>
<span class="sd">           of such instances, which will receive pre- and post- commit and</span>
<span class="sd">           flush events, as well as a post-rollback event. **Deprecated.**</span>
<span class="sd">           Please see :class:`.SessionEvents`.</span>

<span class="sd">        :param info: optional dictionary of arbitrary data to be associated</span>
<span class="sd">           with this :class:`.Session`.  Is available via the</span>
<span class="sd">           :attr:`.Session.info` attribute.  Note the dictionary is copied at</span>
<span class="sd">           construction time so that modifications to the per-</span>
<span class="sd">           :class:`.Session` dictionary will be local to that</span>
<span class="sd">           :class:`.Session`.</span>

<span class="sd">           .. versionadded:: 0.9.0</span>

<span class="sd">        :param query_cls:  Class which should be used to create new Query</span>
<span class="sd">          objects, as returned by the :meth:`~.Session.query` method.</span>
<span class="sd">          Defaults to :class:`.Query`.</span>

<span class="sd">        :param twophase:  When ``True``, all transactions will be started as</span>
<span class="sd">            a &quot;two phase&quot; transaction, i.e. using the &quot;two phase&quot; semantics</span>
<span class="sd">            of the database in use along with an XID.  During a</span>
<span class="sd">            :meth:`~.commit`, after :meth:`~.flush` has been issued for all</span>
<span class="sd">            attached databases, the :meth:`~.TwoPhaseTransaction.prepare`</span>
<span class="sd">            method on each database&#39;s :class:`.TwoPhaseTransaction` will be</span>
<span class="sd">            called. This allows each database to roll back the entire</span>
<span class="sd">            transaction, before each transaction is committed.</span>

<span class="sd">        :param weak_identity_map:  Defaults to ``True`` - when set to</span>
<span class="sd">           ``False``, objects placed in the :class:`.Session` will be</span>
<span class="sd">           strongly referenced until explicitly removed or the</span>
<span class="sd">           :class:`.Session` is closed.  **Deprecated** - this option</span>
<span class="sd">           is obsolete.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">weak_identity_map</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_identity_cls</span> <span class="o">=</span> <span class="n">identity</span><span class="o">.</span><span class="n">WeakInstanceDict</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">util</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span><span class="s2">&quot;weak_identity_map=False is deprecated.  &quot;</span>
                                 <span class="s2">&quot;This feature is not needed.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_identity_cls</span> <span class="o">=</span> <span class="n">identity</span><span class="o">.</span><span class="n">StrongInstanceDict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identity_cls</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="p">{}</span>   <span class="c1"># InstanceState-&gt;object, strong refs object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># same</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bind</span> <span class="o">=</span> <span class="n">bind</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span> <span class="o">=</span> <span class="n">_new_sessionid</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="n">autoflush</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span> <span class="o">=</span> <span class="n">autocommit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expire_on_commit</span> <span class="o">=</span> <span class="n">expire_on_commit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span> <span class="o">=</span> <span class="n">_enable_transaction_accounting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">twophase</span> <span class="o">=</span> <span class="n">twophase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_query_cls</span> <span class="o">=</span> <span class="n">query_cls</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">extension</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="n">util</span><span class="o">.</span><span class="n">to_list</span><span class="p">(</span><span class="n">extension</span><span class="p">):</span>
                <span class="n">SessionExtension</span><span class="o">.</span><span class="n">_adapt_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ext</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">bind</span> <span class="ow">in</span> <span class="n">binds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_add_bind</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">bind</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
        <span class="n">_sessions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="n">connection_callable</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">transaction</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;The current active or inactive :class:`.SessionTransaction`.&quot;&quot;&quot;</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">memoized_property</span>
    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A user-modifiable dictionary.</span>

<span class="sd">        The initial value of this dictioanry can be populated using the</span>
<span class="sd">        ``info`` argument to the :class:`.Session` constructor or</span>
<span class="sd">        :class:`.sessionmaker` constructor or factory methods.  The dictionary</span>
<span class="sd">        here is always local to this :class:`.Session` and can be modified</span>
<span class="sd">        independently of all other :class:`.Session` objects.</span>

<span class="sd">        .. versionadded:: 0.9.0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">begin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subtransactions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Begin a transaction on this :class:`.Session`.</span>

<span class="sd">        If this Session is already within a transaction, either a plain</span>
<span class="sd">        transaction or nested transaction, an error is raised, unless</span>
<span class="sd">        ``subtransactions=True`` or ``nested=True`` is specified.</span>

<span class="sd">        The ``subtransactions=True`` flag indicates that this</span>
<span class="sd">        :meth:`~.Session.begin` can create a subtransaction if a transaction</span>
<span class="sd">        is already in progress. For documentation on subtransactions, please</span>
<span class="sd">        see :ref:`session_subtransactions`.</span>

<span class="sd">        The ``nested`` flag begins a SAVEPOINT transaction and is equivalent</span>
<span class="sd">        to calling :meth:`~.Session.begin_nested`. For documentation on</span>
<span class="sd">        SAVEPOINT transactions, please see :ref:`session_begin_nested`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">subtransactions</span> <span class="ow">or</span> <span class="n">nested</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_begin</span><span class="p">(</span>
                    <span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;A transaction is already begun.  Use &quot;</span>
                    <span class="s2">&quot;subtransactions=True to allow subtransactions.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">SessionTransaction</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">,</span> <span class="n">nested</span><span class="o">=</span><span class="n">nested</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span>  <span class="c1"># needed for __enter__/__exit__ hook</span>

    <span class="k">def</span> <span class="nf">begin_nested</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Begin a `nested` transaction on this Session.</span>

<span class="sd">        The target database(s) must support SQL SAVEPOINTs or a</span>
<span class="sd">        SQLAlchemy-supported vendor implementation of the idea.</span>

<span class="sd">        For documentation on SAVEPOINT</span>
<span class="sd">        transactions, please see :ref:`session_begin_nested`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span><span class="n">nested</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">rollback</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rollback the current transaction in progress.</span>

<span class="sd">        If no transaction is in progress, this method is a pass-through.</span>

<span class="sd">        This method rolls back the current transaction or nested transaction</span>
<span class="sd">        regardless of subtransactions being in effect.  All subtransactions up</span>
<span class="sd">        to the first real transaction are closed.  Subtransactions occur when</span>
<span class="sd">        :meth:`.begin` is called multiple times.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_rollback`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">rollback</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush pending changes and commit the current transaction.</span>

<span class="sd">        If no transaction is in progress, this method raises an</span>
<span class="sd">        :exc:`~sqlalchemy.exc.InvalidRequestError`.</span>

<span class="sd">        By default, the :class:`.Session` also expires all database</span>
<span class="sd">        loaded state on all ORM-managed attributes after transaction commit.</span>
<span class="sd">        This so that subsequent operations load the most recent</span>
<span class="sd">        data from the database.   This behavior can be disabled using</span>
<span class="sd">        the ``expire_on_commit=False`` option to :class:`.sessionmaker` or</span>
<span class="sd">        the :class:`.Session` constructor.</span>

<span class="sd">        If a subtransaction is in effect (which occurs when begin() is called</span>
<span class="sd">        multiple times), the subtransaction will be closed, and the next call</span>
<span class="sd">        to ``commit()`` will operate on the enclosing transaction.</span>

<span class="sd">        When using the :class:`.Session` in its default mode of</span>
<span class="sd">        ``autocommit=False``, a new transaction will</span>
<span class="sd">        be begun immediately after the commit, but note that the newly begun</span>
<span class="sd">        transaction does *not* use any connection resources until the first</span>
<span class="sd">        SQL is actually emitted.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_committing`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;No transaction is begun.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Prepare the current transaction in progress for two phase commit.</span>

<span class="sd">        If no transaction is in progress, this method raises an</span>
<span class="sd">        :exc:`~sqlalchemy.exc.InvalidRequestError`.</span>

<span class="sd">        Only root transactions of two phase sessions can be prepared. If the</span>
<span class="sd">        current transaction is not such, an</span>
<span class="sd">        :exc:`~sqlalchemy.exc.InvalidRequestError` is raised.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">autocommit</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;No transaction is begun.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">prepare</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clause</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">close_with_result</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">execution_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a :class:`.Connection` object corresponding to this</span>
<span class="sd">        :class:`.Session` object&#39;s transactional state.</span>

<span class="sd">        If this :class:`.Session` is configured with ``autocommit=False``,</span>
<span class="sd">        either the :class:`.Connection` corresponding to the current</span>
<span class="sd">        transaction is returned, or if no transaction is in progress, a new</span>
<span class="sd">        one is begun and the :class:`.Connection` returned (note that no</span>
<span class="sd">        transactional state is established with the DBAPI until the first</span>
<span class="sd">        SQL statement is emitted).</span>

<span class="sd">        Alternatively, if this :class:`.Session` is configured with</span>
<span class="sd">        ``autocommit=True``, an ad-hoc :class:`.Connection` is returned</span>
<span class="sd">        using :meth:`.Engine.contextual_connect` on the underlying</span>
<span class="sd">        :class:`.Engine`.</span>

<span class="sd">        Ambiguity in multi-bind or unbound :class:`.Session` objects can be</span>
<span class="sd">        resolved through any of the optional keyword arguments.   This</span>
<span class="sd">        ultimately makes usage of the :meth:`.get_bind` method for resolution.</span>

<span class="sd">        :param bind:</span>
<span class="sd">          Optional :class:`.Engine` to be used as the bind.  If</span>
<span class="sd">          this engine is already involved in an ongoing transaction,</span>
<span class="sd">          that connection will be used.  This argument takes precedence</span>
<span class="sd">          over ``mapper``, ``clause``.</span>

<span class="sd">        :param mapper:</span>
<span class="sd">          Optional :func:`.mapper` mapped class, used to identify</span>
<span class="sd">          the appropriate bind.  This argument takes precedence over</span>
<span class="sd">          ``clause``.</span>

<span class="sd">        :param clause:</span>
<span class="sd">            A :class:`.ClauseElement` (i.e. :func:`~.sql.expression.select`,</span>
<span class="sd">            :func:`~.sql.expression.text`,</span>
<span class="sd">            etc.) which will be used to locate a bind, if a bind</span>
<span class="sd">            cannot otherwise be identified.</span>

<span class="sd">        :param close_with_result: Passed to :meth:`.Engine.connect`,</span>
<span class="sd">          indicating the :class:`.Connection` should be considered</span>
<span class="sd">          &quot;single use&quot;, automatically closing when the first result set is</span>
<span class="sd">          closed.  This flag only has an effect if this :class:`.Session` is</span>
<span class="sd">          configured with ``autocommit=True`` and does not already have a</span>
<span class="sd">          transaction in progress.</span>

<span class="sd">        :param execution_options: a dictionary of execution options that will</span>
<span class="sd">         be passed to :meth:`.Connection.execution_options`, **when the</span>
<span class="sd">         connection is first procured only**.   If the connection is already</span>
<span class="sd">         present within the :class:`.Session`, a warning is emitted and</span>
<span class="sd">         the arguments are ignored.</span>

<span class="sd">         .. versionadded:: 0.9.9</span>

<span class="sd">         .. seealso::</span>

<span class="sd">            :ref:`session_transaction_isolation`</span>

<span class="sd">        :param \**kw:</span>
<span class="sd">          Additional keyword arguments are sent to :meth:`get_bind()`,</span>
<span class="sd">          allowing additional arguments to be passed to custom</span>
<span class="sd">          implementations of :meth:`get_bind`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bind</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">clause</span><span class="o">=</span><span class="n">clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span><span class="n">bind</span><span class="p">,</span>
                                         <span class="n">close_with_result</span><span class="o">=</span><span class="n">close_with_result</span><span class="p">,</span>
                                         <span class="n">execution_options</span><span class="o">=</span><span class="n">execution_options</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_connection_for_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">engine</span><span class="p">,</span> <span class="n">execution_options</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span>
                <span class="n">engine</span><span class="p">,</span> <span class="n">execution_options</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">engine</span><span class="o">.</span><span class="n">contextual_connect</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">execution_options</span><span class="p">:</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">execution_options</span><span class="p">(</span><span class="o">**</span><span class="n">execution_options</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">conn</span>

    <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clause</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute a SQL expression construct or string statement within</span>
<span class="sd">        the current transaction.</span>

<span class="sd">        Returns a :class:`.ResultProxy` representing</span>
<span class="sd">        results of the statement execution, in the same manner as that of an</span>
<span class="sd">        :class:`.Engine` or</span>
<span class="sd">        :class:`.Connection`.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            result = session.execute(</span>
<span class="sd">                        user_table.select().where(user_table.c.id == 5)</span>
<span class="sd">                    )</span>

<span class="sd">        :meth:`~.Session.execute` accepts any executable clause construct,</span>
<span class="sd">        such as :func:`~.sql.expression.select`,</span>
<span class="sd">        :func:`~.sql.expression.insert`,</span>
<span class="sd">        :func:`~.sql.expression.update`,</span>
<span class="sd">        :func:`~.sql.expression.delete`, and</span>
<span class="sd">        :func:`~.sql.expression.text`.  Plain SQL strings can be passed</span>
<span class="sd">        as well, which in the case of :meth:`.Session.execute` only</span>
<span class="sd">        will be interpreted the same as if it were passed via a</span>
<span class="sd">        :func:`~.expression.text` construct.  That is, the following usage::</span>

<span class="sd">            result = session.execute(</span>
<span class="sd">                        &quot;SELECT * FROM user WHERE id=:param&quot;,</span>
<span class="sd">                        {&quot;param&quot;:5}</span>
<span class="sd">                    )</span>

<span class="sd">        is equivalent to::</span>

<span class="sd">            from sqlalchemy import text</span>
<span class="sd">            result = session.execute(</span>
<span class="sd">                        text(&quot;SELECT * FROM user WHERE id=:param&quot;),</span>
<span class="sd">                        {&quot;param&quot;:5}</span>
<span class="sd">                    )</span>

<span class="sd">        The second positional argument to :meth:`.Session.execute` is an</span>
<span class="sd">        optional parameter set.  Similar to that of</span>
<span class="sd">        :meth:`.Connection.execute`, whether this is passed as a single</span>
<span class="sd">        dictionary, or a list of dictionaries, determines whether the DBAPI</span>
<span class="sd">        cursor&#39;s ``execute()`` or ``executemany()`` is used to execute the</span>
<span class="sd">        statement.   An INSERT construct may be invoked for a single row::</span>

<span class="sd">            result = session.execute(</span>
<span class="sd">                users.insert(), {&quot;id&quot;: 7, &quot;name&quot;: &quot;somename&quot;})</span>

<span class="sd">        or for multiple rows::</span>

<span class="sd">            result = session.execute(users.insert(), [</span>
<span class="sd">                                    {&quot;id&quot;: 7, &quot;name&quot;: &quot;somename7&quot;},</span>
<span class="sd">                                    {&quot;id&quot;: 8, &quot;name&quot;: &quot;somename8&quot;},</span>
<span class="sd">                                    {&quot;id&quot;: 9, &quot;name&quot;: &quot;somename9&quot;}</span>
<span class="sd">                                ])</span>

<span class="sd">        The statement is executed within the current transactional context of</span>
<span class="sd">        this :class:`.Session`.   The :class:`.Connection` which is used</span>
<span class="sd">        to execute the statement can also be acquired directly by</span>
<span class="sd">        calling the :meth:`.Session.connection` method.  Both methods use</span>
<span class="sd">        a rule-based resolution scheme in order to determine the</span>
<span class="sd">        :class:`.Connection`, which in the average case is derived directly</span>
<span class="sd">        from the &quot;bind&quot; of the :class:`.Session` itself, and in other cases</span>
<span class="sd">        can be based on the :func:`.mapper`</span>
<span class="sd">        and :class:`.Table` objects passed to the method; see the</span>
<span class="sd">        documentation for :meth:`.Session.get_bind` for a full description of</span>
<span class="sd">        this scheme.</span>

<span class="sd">        The :meth:`.Session.execute` method does *not* invoke autoflush.</span>

<span class="sd">        The :class:`.ResultProxy` returned by the :meth:`.Session.execute`</span>
<span class="sd">        method is returned with the &quot;close_with_result&quot; flag set to true;</span>
<span class="sd">        the significance of this flag is that if this :class:`.Session` is</span>
<span class="sd">        autocommitting and does not have a transaction-dedicated</span>
<span class="sd">        :class:`.Connection` available, a temporary :class:`.Connection` is</span>
<span class="sd">        established for the statement execution, which is closed (meaning,</span>
<span class="sd">        returned to the connection pool) when the :class:`.ResultProxy` has</span>
<span class="sd">        consumed all available data. This applies *only* when the</span>
<span class="sd">        :class:`.Session` is configured with autocommit=True and no</span>
<span class="sd">        transaction has been started.</span>

<span class="sd">        :param clause:</span>
<span class="sd">            An executable statement (i.e. an :class:`.Executable` expression</span>
<span class="sd">            such as :func:`.expression.select`) or string SQL statement</span>
<span class="sd">            to be executed.</span>

<span class="sd">        :param params:</span>
<span class="sd">            Optional dictionary, or list of dictionaries, containing</span>
<span class="sd">            bound parameter values.   If a single dictionary, single-row</span>
<span class="sd">            execution occurs; if a list of dictionaries, an</span>
<span class="sd">            &quot;executemany&quot; will be invoked.  The keys in each dictionary</span>
<span class="sd">            must correspond to parameter names present in the statement.</span>

<span class="sd">        :param mapper:</span>
<span class="sd">          Optional :func:`.mapper` or mapped class, used to identify</span>
<span class="sd">          the appropriate bind.  This argument takes precedence over</span>
<span class="sd">          ``clause`` when locating a bind.   See :meth:`.Session.get_bind`</span>
<span class="sd">          for more details.</span>

<span class="sd">        :param bind:</span>
<span class="sd">          Optional :class:`.Engine` to be used as the bind.  If</span>
<span class="sd">          this engine is already involved in an ongoing transaction,</span>
<span class="sd">          that connection will be used.  This argument takes</span>
<span class="sd">          precedence over ``mapper`` and ``clause`` when locating</span>
<span class="sd">          a bind.</span>

<span class="sd">        :param \**kw:</span>
<span class="sd">          Additional keyword arguments are sent to :meth:`.Session.get_bind()`</span>
<span class="sd">          to allow extensibility of &quot;bind&quot; schemes.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`sqlexpression_toplevel` - Tutorial on using Core SQL</span>
<span class="sd">            constructs.</span>

<span class="sd">            :ref:`connections_toplevel` - Further information on direct</span>
<span class="sd">            statement execution.</span>

<span class="sd">            :meth:`.Connection.execute` - core level statement execution</span>
<span class="sd">            method, which is :meth:`.Session.execute` ultimately uses</span>
<span class="sd">            in order to execute the statement.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">clause</span> <span class="o">=</span> <span class="n">expression</span><span class="o">.</span><span class="n">_literal_as_text</span><span class="p">(</span><span class="n">clause</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bind</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">bind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bind</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">clause</span><span class="o">=</span><span class="n">clause</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_connection_for_bind</span><span class="p">(</span>
            <span class="n">bind</span><span class="p">,</span> <span class="n">close_with_result</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clause</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Like :meth:`~.Session.execute` but return a scalar result.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
            <span class="n">clause</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="n">mapper</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="n">bind</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close this Session.</span>

<span class="sd">        This clears all items and ends any transaction in progress.</span>

<span class="sd">        If this session were created with ``autocommit=False``, a new</span>
<span class="sd">        transaction is immediately begun.  Note that this new transaction does</span>
<span class="sd">        not use any connection resources until they are first needed.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_impl</span><span class="p">(</span><span class="n">invalidate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close this Session, using connection invalidation.</span>

<span class="sd">        This is a variant of :meth:`.Session.close` that will additionally</span>
<span class="sd">        ensure that the :meth:`.Connection.invalidate` method will be called</span>
<span class="sd">        on all :class:`.Connection` objects.  This can be called when</span>
<span class="sd">        the database is known to be in a state where the connections are</span>
<span class="sd">        no longer safe to be used.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            try:</span>
<span class="sd">                sess = Session()</span>
<span class="sd">                sess.add(User())</span>
<span class="sd">                sess.commit()</span>
<span class="sd">            except gevent.Timeout:</span>
<span class="sd">                sess.invalidate()</span>
<span class="sd">                raise</span>
<span class="sd">            except:</span>
<span class="sd">                sess.rollback()</span>
<span class="sd">                raise</span>

<span class="sd">        This clears all items and ends any transaction in progress.</span>

<span class="sd">        If this session were created with ``autocommit=False``, a new</span>
<span class="sd">        transaction is immediately begun.  Note that this new transaction does</span>
<span class="sd">        not use any connection resources until they are first needed.</span>

<span class="sd">        .. versionadded:: 0.9.9</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_impl</span><span class="p">(</span><span class="n">invalidate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_close_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">invalidate</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expunge_all</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">transaction</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_iterate_parents</span><span class="p">():</span>
                <span class="n">transaction</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">invalidate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expunge_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove all object instances from this ``Session``.</span>

<span class="sd">        This is equivalent to calling ``expunge(obj)`` on all objects in this</span>
<span class="sd">        ``Session``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">all_states</span><span class="p">()</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">):</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_detach</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_identity_cls</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># TODO: need much more test coverage for bind_mapper() and similar !</span>
    <span class="c1"># TODO: + crystallize + document resolution order</span>
    <span class="c1">#       vis. bind_mapper/bind_table</span>

    <span class="k">def</span> <span class="nf">_add_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">bind</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">insp</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">NoInspectionAvailable</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                            <span class="s2">&quot;Not acceptable bind target: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                            <span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">insp</span><span class="o">.</span><span class="n">is_selectable</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">insp</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
            <span class="k">elif</span> <span class="n">insp</span><span class="o">.</span><span class="n">is_mapper</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">insp</span><span class="o">.</span><span class="n">class_</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
                <span class="k">for</span> <span class="n">selectable</span> <span class="ow">in</span> <span class="n">insp</span><span class="o">.</span><span class="n">_all_tables</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">selectable</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">ArgumentError</span><span class="p">(</span>
                            <span class="s2">&quot;Not acceptable bind target: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                            <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bind_mapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">bind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Associate a :class:`.Mapper` with a &quot;bind&quot;, e.g. a :class:`.Engine`</span>
<span class="sd">        or :class:`.Connection`.</span>

<span class="sd">        The given mapper is added to a lookup used by the</span>
<span class="sd">        :meth:`.Session.get_bind` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_bind</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">bind</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bind_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">bind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Associate a :class:`.Table` with a &quot;bind&quot;, e.g. a :class:`.Engine`</span>
<span class="sd">        or :class:`.Connection`.</span>

<span class="sd">        The given mapper is added to a lookup used by the</span>
<span class="sd">        :meth:`.Session.get_bind` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_bind</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">bind</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_bind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clause</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a &quot;bind&quot; to which this :class:`.Session` is bound.</span>

<span class="sd">        The &quot;bind&quot; is usually an instance of :class:`.Engine`,</span>
<span class="sd">        except in the case where the :class:`.Session` has been</span>
<span class="sd">        explicitly bound directly to a :class:`.Connection`.</span>

<span class="sd">        For a multiply-bound or unbound :class:`.Session`, the</span>
<span class="sd">        ``mapper`` or ``clause`` arguments are used to determine the</span>
<span class="sd">        appropriate bind to return.</span>

<span class="sd">        Note that the &quot;mapper&quot; argument is usually present</span>
<span class="sd">        when :meth:`.Session.get_bind` is called via an ORM</span>
<span class="sd">        operation such as a :meth:`.Session.query`, each</span>
<span class="sd">        individual INSERT/UPDATE/DELETE operation within a</span>
<span class="sd">        :meth:`.Session.flush`, call, etc.</span>

<span class="sd">        The order of resolution is:</span>

<span class="sd">        1. if mapper given and session.binds is present,</span>
<span class="sd">           locate a bind based on mapper.</span>
<span class="sd">        2. if clause given and session.binds is present,</span>
<span class="sd">           locate a bind based on :class:`.Table` objects</span>
<span class="sd">           found in the given clause present in session.binds.</span>
<span class="sd">        3. if session.bind is present, return that.</span>
<span class="sd">        4. if clause given, attempt to return a bind</span>
<span class="sd">           linked to the :class:`.MetaData` ultimately</span>
<span class="sd">           associated with the clause.</span>
<span class="sd">        5. if mapper given, attempt to return a bind</span>
<span class="sd">           linked to the :class:`.MetaData` ultimately</span>
<span class="sd">           associated with the :class:`.Table` or other</span>
<span class="sd">           selectable to which the mapper is mapped.</span>
<span class="sd">        6. No bind can be found, :exc:`~sqlalchemy.exc.UnboundExecutionError`</span>
<span class="sd">           is raised.</span>

<span class="sd">        :param mapper:</span>
<span class="sd">          Optional :func:`.mapper` mapped class or instance of</span>
<span class="sd">          :class:`.Mapper`.   The bind can be derived from a :class:`.Mapper`</span>
<span class="sd">          first by consulting the &quot;binds&quot; map associated with this</span>
<span class="sd">          :class:`.Session`, and secondly by consulting the :class:`.MetaData`</span>
<span class="sd">          associated with the :class:`.Table` to which the :class:`.Mapper`</span>
<span class="sd">          is mapped for a bind.</span>

<span class="sd">        :param clause:</span>
<span class="sd">            A :class:`.ClauseElement` (i.e. :func:`~.sql.expression.select`,</span>
<span class="sd">            :func:`~.sql.expression.text`,</span>
<span class="sd">            etc.).  If the ``mapper`` argument is not present or could not</span>
<span class="sd">            produce a bind, the given expression construct will be searched</span>
<span class="sd">            for a bound element, typically a :class:`.Table` associated with</span>
<span class="sd">            bound :class:`.MetaData`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="n">clause</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">UnboundExecutionError</span><span class="p">(</span>
                    <span class="s2">&quot;This session is not bound to a single Engine or &quot;</span>
                    <span class="s2">&quot;Connection, and no context was provided to locate &quot;</span>
                    <span class="s2">&quot;a binding.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mapper</span> <span class="o">=</span> <span class="n">inspect</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">NoInspectionAvailable</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedClassError</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mapper</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="n">__mro__</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cls</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">cls</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">clause</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">clause</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">mapped_table</span>

            <span class="k">if</span> <span class="n">clause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">sql_util</span><span class="o">.</span><span class="n">find_tables</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">include_crud</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__binds</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bind</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">clause</span><span class="p">,</span> <span class="n">sql</span><span class="o">.</span><span class="n">expression</span><span class="o">.</span><span class="n">ClauseElement</span><span class="p">)</span> <span class="ow">and</span> <span class="n">clause</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">clause</span><span class="o">.</span><span class="n">bind</span>

        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">and</span> <span class="n">mapper</span><span class="o">.</span><span class="n">mapped_table</span><span class="o">.</span><span class="n">bind</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mapper</span><span class="o">.</span><span class="n">mapped_table</span><span class="o">.</span><span class="n">bind</span>

        <span class="n">context</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">mapper</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;mapper </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">mapper</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">clause</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;SQL expression&#39;</span><span class="p">)</span>

        <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">UnboundExecutionError</span><span class="p">(</span>
            <span class="s2">&quot;Could not locate a bind configured on </span><span class="si">%s</span><span class="s2"> or this Session&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">context</span><span class="p">)))</span>

    <span class="k">def</span> <span class="nf">query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">entities</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a new :class:`.Query` object corresponding to this</span>
<span class="sd">        :class:`.Session`.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_query_cls</span><span class="p">(</span><span class="n">entities</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@util</span><span class="o">.</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">no_autoflush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a context manager that disables autoflush.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            with session.no_autoflush:</span>

<span class="sd">                some_object = SomeClass()</span>
<span class="sd">                session.add(some_object)</span>
<span class="sd">                # won&#39;t autoflush</span>
<span class="sd">                some_object.related_thing = session.query(SomeRelated).first()</span>

<span class="sd">        Operations that proceed within the ``with:`` block</span>
<span class="sd">        will not be subject to flushes occurring upon query</span>
<span class="sd">        access.  This is useful when initializing a series</span>
<span class="sd">        of objects which involve existing database queries,</span>
<span class="sd">        where the uncompleted object should not yet be flushed.</span>

<span class="sd">        .. versionadded:: 0.7.6</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">autoflush</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">yield</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="n">autoflush</span>

    <span class="k">def</span> <span class="nf">_autoflush</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">StatementError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># note we are reraising StatementError as opposed to</span>
                <span class="c1"># raising FlushError with &quot;chaining&quot; to remain compatible</span>
                <span class="c1"># with code that catches StatementError, IntegrityError,</span>
                <span class="c1"># etc.</span>
                <span class="n">e</span><span class="o">.</span><span class="n">add_detail</span><span class="p">(</span>
                    <span class="s2">&quot;raised as a result of Query-invoked autoflush; &quot;</span>
                    <span class="s2">&quot;consider using a session.no_autoflush block if this &quot;</span>
                    <span class="s2">&quot;flush is occurring prematurely&quot;</span><span class="p">)</span>
                <span class="n">util</span><span class="o">.</span><span class="n">raise_from_cause</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">attribute_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lockmode</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expire and refresh the attributes on the given instance.</span>

<span class="sd">        A query will be issued to the database and all attributes will be</span>
<span class="sd">        refreshed with their current database value.</span>

<span class="sd">        Lazy-loaded relational attributes will remain lazily loaded, so that</span>
<span class="sd">        the instance-wide refresh operation will be followed immediately by</span>
<span class="sd">        the lazy load of that attribute.</span>

<span class="sd">        Eagerly-loaded relational attributes will eagerly load within the</span>
<span class="sd">        single refresh operation.</span>

<span class="sd">        Note that a highly isolated transaction will return the same values as</span>
<span class="sd">        were previously read in that same transaction, regardless of changes</span>
<span class="sd">        in database state outside of that transaction - usage of</span>
<span class="sd">        :meth:`~Session.refresh` usually only makes sense if non-ORM SQL</span>
<span class="sd">        statement were emitted in the ongoing transaction, or if autocommit</span>
<span class="sd">        mode is turned on.</span>

<span class="sd">        :param attribute_names: optional.  An iterable collection of</span>
<span class="sd">          string attribute names indicating a subset of attributes to</span>
<span class="sd">          be refreshed.</span>

<span class="sd">        :param lockmode: Passed to the :class:`~sqlalchemy.orm.query.Query`</span>
<span class="sd">          as used by :meth:`~sqlalchemy.orm.query.Query.with_lockmode`.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_expire` - introductory material</span>

<span class="sd">            :meth:`.Session.expire`</span>

<span class="sd">            :meth:`.Session.expire_all`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_expire_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">attribute_names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">loading</span><span class="o">.</span><span class="n">load_on_ident</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">object_mapper</span><span class="p">(</span><span class="n">instance</span><span class="p">)),</span>
                <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">refresh_state</span><span class="o">=</span><span class="n">state</span><span class="p">,</span>
                <span class="n">lockmode</span><span class="o">=</span><span class="n">lockmode</span><span class="p">,</span>
                <span class="n">only_load_props</span><span class="o">=</span><span class="n">attribute_names</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Could not refresh instance &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span>
                <span class="n">instance_str</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">expire_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expires all persistent instances within this Session.</span>

<span class="sd">        When any attributes on a persistent instance is next accessed,</span>
<span class="sd">        a query will be issued using the</span>
<span class="sd">        :class:`.Session` object&#39;s current transactional context in order to</span>
<span class="sd">        load all expired attributes for the given instance.   Note that</span>
<span class="sd">        a highly isolated transaction will return the same values as were</span>
<span class="sd">        previously read in that same transaction, regardless of changes</span>
<span class="sd">        in database state outside of that transaction.</span>

<span class="sd">        To expire individual objects and individual attributes</span>
<span class="sd">        on those objects, use :meth:`Session.expire`.</span>

<span class="sd">        The :class:`.Session` object&#39;s default behavior is to</span>
<span class="sd">        expire all state whenever the :meth:`Session.rollback`</span>
<span class="sd">        or :meth:`Session.commit` methods are called, so that new</span>
<span class="sd">        state can be loaded for the new transaction.   For this reason,</span>
<span class="sd">        calling :meth:`Session.expire_all` should not be needed when</span>
<span class="sd">        autocommit is ``False``, assuming the transaction is isolated.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_expire` - introductory material</span>

<span class="sd">            :meth:`.Session.expire`</span>

<span class="sd">            :meth:`.Session.refresh`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">all_states</span><span class="p">():</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_expire</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">expire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">attribute_names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expire the attributes on an instance.</span>

<span class="sd">        Marks the attributes of an instance as out of date. When an expired</span>
<span class="sd">        attribute is next accessed, a query will be issued to the</span>
<span class="sd">        :class:`.Session` object&#39;s current transactional context in order to</span>
<span class="sd">        load all expired attributes for the given instance.   Note that</span>
<span class="sd">        a highly isolated transaction will return the same values as were</span>
<span class="sd">        previously read in that same transaction, regardless of changes</span>
<span class="sd">        in database state outside of that transaction.</span>

<span class="sd">        To expire all objects in the :class:`.Session` simultaneously,</span>
<span class="sd">        use :meth:`Session.expire_all`.</span>

<span class="sd">        The :class:`.Session` object&#39;s default behavior is to</span>
<span class="sd">        expire all state whenever the :meth:`Session.rollback`</span>
<span class="sd">        or :meth:`Session.commit` methods are called, so that new</span>
<span class="sd">        state can be loaded for the new transaction.   For this reason,</span>
<span class="sd">        calling :meth:`Session.expire` only makes sense for the specific</span>
<span class="sd">        case that a non-ORM SQL statement was emitted in the current</span>
<span class="sd">        transaction.</span>

<span class="sd">        :param instance: The instance to be refreshed.</span>
<span class="sd">        :param attribute_names: optional list of string attribute names</span>
<span class="sd">          indicating a subset of attributes to be expired.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`session_expire` - introductory material</span>

<span class="sd">            :meth:`.Session.expire`</span>

<span class="sd">            :meth:`.Session.refresh`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expire_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">attribute_names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expire_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">attribute_names</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validate_persistent</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attribute_names</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_expire_attributes</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="n">attribute_names</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># pre-fetch the full cascade since the expire is going to</span>
            <span class="c1"># remove associations</span>
            <span class="n">cascaded</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">cascade_iterator</span><span class="p">(</span>
                <span class="s1">&#39;refresh-expire&#39;</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_conditional_expire</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">st_</span><span class="p">,</span> <span class="n">dct_</span> <span class="ow">in</span> <span class="n">cascaded</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_conditional_expire</span><span class="p">(</span><span class="n">st_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_conditional_expire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expire a state if persistent, else expunge if pending&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_expire</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_detach</span><span class="p">()</span>

    <span class="nd">@util</span><span class="o">.</span><span class="n">deprecated</span><span class="p">(</span><span class="s2">&quot;0.7&quot;</span><span class="p">,</span> <span class="s2">&quot;The non-weak-referencing identity map &quot;</span>
                     <span class="s2">&quot;feature is no longer needed.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">prune</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove unreferenced instances cached in the identity map.</span>

<span class="sd">        Note that this method is only meaningful if &quot;weak_identity_map&quot; is set</span>
<span class="sd">        to False.  The default weak identity map is self-pruning.</span>

<span class="sd">        Removes any object in this Session&#39;s identity map that is not</span>
<span class="sd">        referenced in user code, modified, new or scheduled for deletion.</span>
<span class="sd">        Returns the number of objects pruned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">prune</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">expunge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Remove the `instance` from this ``Session``.</span>

<span class="sd">        This will free all internal references to the instance.  Cascading</span>
<span class="sd">        will be applied according to the *expunge* cascade rule.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Instance </span><span class="si">%s</span><span class="s2"> is not present in this Session&quot;</span> <span class="o">%</span>
                <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>

        <span class="n">cascaded</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">cascade_iterator</span><span class="p">(</span>
            <span class="s1">&#39;expunge&#39;</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_expunge_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">st_</span><span class="p">,</span> <span class="n">dct_</span> <span class="ow">in</span> <span class="n">cascaded</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_expunge_state</span><span class="p">(</span><span class="n">st_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_expunge_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_detach</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">safe_discard</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_detach</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">_detach</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_register_newly_persistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="n">mapper</span> <span class="o">=</span> <span class="n">_state_mapper</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

            <span class="c1"># prevent against last minute dereferences of the object</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">instance_key</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_from_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">_none_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">instance_key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">and</span> \
                        <span class="ow">not</span> <span class="n">mapper</span><span class="o">.</span><span class="n">allow_partial_pks</span> <span class="ow">or</span> \
                        <span class="n">_none_set</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">instance_key</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">FlushError</span><span class="p">(</span>
                        <span class="s2">&quot;Instance </span><span class="si">%s</span><span class="s2"> has a NULL identity key.  If this is an &quot;</span>
                        <span class="s2">&quot;auto-generated value, check that the database table &quot;</span>
                        <span class="s2">&quot;allows generation of new primary key values, and &quot;</span>
                        <span class="s2">&quot;that the mapped Column object is configured to &quot;</span>
                        <span class="s2">&quot;expect these generated values.  Ensure also that &quot;</span>
                        <span class="s2">&quot;this flush() is not occurring at an inappropriate &quot;</span>
                        <span class="s2">&quot;time, such aswithin a load() event.&quot;</span>
                        <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">instance_key</span>
                <span class="k">elif</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="o">!=</span> <span class="n">instance_key</span><span class="p">:</span>
                    <span class="c1"># primary key switch. use safe_discard() in case another</span>
                    <span class="c1"># state has already replaced this one in the identity</span>
                    <span class="c1"># map (see test/orm/test_naturalpks.py ReversePKsTest)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">safe_discard</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_key_switches</span><span class="p">:</span>
                        <span class="n">orig_key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_key_switches</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">orig_key</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_key_switches</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">orig_key</span><span class="p">,</span> <span class="n">instance_key</span><span class="p">)</span>
                    <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">instance_key</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="n">statelib</span><span class="o">.</span><span class="n">InstanceState</span><span class="o">.</span><span class="n">_commit_all_states</span><span class="p">(</span>
            <span class="p">((</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_register_altered</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
        <span class="c1"># remove from new last, might be the last strong ref</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">states</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_register_altered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_new</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_dirty</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_remove_newly_deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enable_transaction_accounting</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">_deleted</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">safe_discard</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">deleted</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">_warn</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Place an object in the ``Session``.</span>

<span class="sd">        Its state will be persisted to the database on the next flush</span>
<span class="sd">        operation.</span>

<span class="sd">        Repeated calls to ``add()`` will be ignored. The opposite of ``add()``</span>
<span class="sd">        is ``expunge()``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_warn</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_warning</span><span class="p">(</span><span class="s2">&quot;Session.add()&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_save_or_update_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instances</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add the given collection of instances to this ``Session``.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_warning</span><span class="p">(</span><span class="s2">&quot;Session.add_all()&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">instance</span> <span class="ow">in</span> <span class="n">instances</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">_warn</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_or_update_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_or_update_impl</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="n">_state_mapper</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">st_</span><span class="p">,</span> <span class="n">dct_</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">cascade_iterator</span><span class="p">(</span>
                <span class="s1">&#39;save-update&#39;</span><span class="p">,</span>
                <span class="n">state</span><span class="p">,</span>
                <span class="n">halt_on</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_contains_state</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_or_update_impl</span><span class="p">(</span><span class="n">st_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mark an instance as deleted.</span>

<span class="sd">        The database delete operation occurs upon ``flush()``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_warning</span><span class="p">(</span><span class="s2">&quot;Session.delete()&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Instance &#39;</span><span class="si">%s</span><span class="s2">&#39; is not persisted&quot;</span> <span class="o">%</span>
                <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># ensure object is attached to allow the</span>
        <span class="c1"># cascade operation to load deferred attributes</span>
        <span class="c1"># and collections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">include_before</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># grab the cascades before adding the item to the deleted list</span>
        <span class="c1"># so that autoflush does not delete the item</span>
        <span class="c1"># the strong reference to the instance itself is significant here</span>
        <span class="n">cascade_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">cascade_iterator</span><span class="p">(</span>
            <span class="s1">&#39;delete&#39;</span><span class="p">,</span> <span class="n">state</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">st_</span><span class="p">,</span> <span class="n">dct_</span> <span class="ow">in</span> <span class="n">cascade_states</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_delete_impl</span><span class="p">(</span><span class="n">st_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copy the state of a given instance into a corresponding instance</span>
<span class="sd">        within this :class:`.Session`.</span>

<span class="sd">        :meth:`.Session.merge` examines the primary key attributes of the</span>
<span class="sd">        source instance, and attempts to reconcile it with an instance of the</span>
<span class="sd">        same primary key in the session.   If not found locally, it attempts</span>
<span class="sd">        to load the object from the database based on primary key, and if</span>
<span class="sd">        none can be located, creates a new instance.  The state of each</span>
<span class="sd">        attribute on the source instance is then copied to the target</span>
<span class="sd">        instance.  The resulting target instance is then returned by the</span>
<span class="sd">        method; the original source instance is left unmodified, and</span>
<span class="sd">        un-associated with the :class:`.Session` if not already.</span>

<span class="sd">        This operation cascades to associated instances if the association is</span>
<span class="sd">        mapped with ``cascade=&quot;merge&quot;``.</span>

<span class="sd">        See :ref:`unitofwork_merging` for a detailed discussion of merging.</span>

<span class="sd">        :param instance: Instance to be merged.</span>
<span class="sd">        :param load: Boolean, when False, :meth:`.merge` switches into</span>
<span class="sd">         a &quot;high performance&quot; mode which causes it to forego emitting history</span>
<span class="sd">         events as well as all database access.  This flag is used for</span>
<span class="sd">         cases such as transferring graphs of objects into a :class:`.Session`</span>
<span class="sd">         from a second level cache, or to transfer just-loaded objects</span>
<span class="sd">         into the :class:`.Session` owned by a worker thread or process</span>
<span class="sd">         without re-querying the database.</span>

<span class="sd">         The ``load=False`` use case adds the caveat that the given</span>
<span class="sd">         object has to be in a &quot;clean&quot; state, that is, has no pending changes</span>
<span class="sd">         to be flushed - even if the incoming object is detached from any</span>
<span class="sd">         :class:`.Session`.   This is so that when</span>
<span class="sd">         the merge operation populates local attributes and</span>
<span class="sd">         cascades to related objects and</span>
<span class="sd">         collections, the values can be &quot;stamped&quot; onto the</span>
<span class="sd">         target object as is, without generating any history or attribute</span>
<span class="sd">         events, and without the need to reconcile the incoming data with</span>
<span class="sd">         any existing related objects or collections that might not</span>
<span class="sd">         be loaded.  The resulting objects from ``load=False`` are always</span>
<span class="sd">         produced as &quot;clean&quot;, so it is only appropriate that the given objects</span>
<span class="sd">         should be &quot;clean&quot; as well, else this suggests a mis-use of the</span>
<span class="sd">         method.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush_warning</span><span class="p">(</span><span class="s2">&quot;Session.merge()&quot;</span><span class="p">)</span>

        <span class="n">_recursive</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">load</span><span class="p">:</span>
            <span class="c1"># flush current contents if we expect to load data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_autoflush</span><span class="p">()</span>

        <span class="n">object_mapper</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>  <span class="c1"># verify mapped</span>
        <span class="n">autoflush</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_merge</span><span class="p">(</span>
                <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span>
                <span class="n">attributes</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">(</span><span class="n">instance</span><span class="p">),</span>
                <span class="n">load</span><span class="o">=</span><span class="n">load</span><span class="p">,</span> <span class="n">_recursive</span><span class="o">=</span><span class="n">_recursive</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoflush</span> <span class="o">=</span> <span class="n">autoflush</span>

    <span class="k">def</span> <span class="nf">_merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">,</span> <span class="n">load</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">_recursive</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="n">_state_mapper</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">_recursive</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_recursive</span><span class="p">[</span><span class="n">state</span><span class="p">]</span>

        <span class="n">new_instance</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">load</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;merge() with load=False option does not support &quot;</span>
                    <span class="s2">&quot;objects transient (i.e. unpersisted) objects.  flush() &quot;</span>
                    <span class="s2">&quot;all changes on mapped instances before merging with &quot;</span>
                    <span class="s2">&quot;load=False.&quot;</span><span class="p">)</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_from_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">load</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">modified</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                    <span class="s2">&quot;merge() with load=False option does not support &quot;</span>
                    <span class="s2">&quot;objects marked as &#39;dirty&#39;.  flush() all changes on &quot;</span>
                    <span class="s2">&quot;mapped instances before merging with load=False.&quot;</span><span class="p">)</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">class_manager</span><span class="o">.</span><span class="n">new_instance</span><span class="p">()</span>
            <span class="n">merged_state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_impl</span><span class="p">(</span><span class="n">merged_state</span><span class="p">)</span>
            <span class="n">new_instance</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">_none_set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">or</span> \
            <span class="p">(</span><span class="n">mapper</span><span class="o">.</span><span class="n">allow_partial_pks</span> <span class="ow">and</span>
             <span class="ow">not</span> <span class="n">_none_set</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">mapper</span><span class="o">.</span><span class="n">class_</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">merged</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">merged</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">class_manager</span><span class="o">.</span><span class="n">new_instance</span><span class="p">()</span>
            <span class="n">merged_state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
            <span class="n">merged_dict</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
            <span class="n">new_instance</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_or_update_state</span><span class="p">(</span><span class="n">merged_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">merged_state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>
            <span class="n">merged_dict</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_dict</span><span class="p">(</span><span class="n">merged</span><span class="p">)</span>

        <span class="n">_recursive</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">merged</span>

        <span class="c1"># check that we didn&#39;t just pull the exact same</span>
        <span class="c1"># state out.</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">merged_state</span><span class="p">:</span>
            <span class="c1"># version check if applicable</span>
            <span class="k">if</span> <span class="n">mapper</span><span class="o">.</span><span class="n">version_id_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">existing_version</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_get_state_attr_by_column</span><span class="p">(</span>
                    <span class="n">state</span><span class="p">,</span>
                    <span class="n">state_dict</span><span class="p">,</span>
                    <span class="n">mapper</span><span class="o">.</span><span class="n">version_id_col</span><span class="p">,</span>
                    <span class="n">passive</span><span class="o">=</span><span class="n">attributes</span><span class="o">.</span><span class="n">PASSIVE_NO_INITIALIZE</span><span class="p">)</span>

                <span class="n">merged_version</span> <span class="o">=</span> <span class="n">mapper</span><span class="o">.</span><span class="n">_get_state_attr_by_column</span><span class="p">(</span>
                    <span class="n">merged_state</span><span class="p">,</span>
                    <span class="n">merged_dict</span><span class="p">,</span>
                    <span class="n">mapper</span><span class="o">.</span><span class="n">version_id_col</span><span class="p">,</span>
                    <span class="n">passive</span><span class="o">=</span><span class="n">attributes</span><span class="o">.</span><span class="n">PASSIVE_NO_INITIALIZE</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">existing_version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">attributes</span><span class="o">.</span><span class="n">PASSIVE_NO_RESULT</span> <span class="ow">and</span> \
                        <span class="n">merged_version</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">attributes</span><span class="o">.</span><span class="n">PASSIVE_NO_RESULT</span> <span class="ow">and</span> \
                        <span class="n">existing_version</span> <span class="o">!=</span> <span class="n">merged_version</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">StaleDataError</span><span class="p">(</span>
                        <span class="s2">&quot;Version id &#39;</span><span class="si">%s</span><span class="s2">&#39; on merged state </span><span class="si">%s</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;does not match existing version &#39;</span><span class="si">%s</span><span class="s2">&#39;. &quot;</span>
                        <span class="s2">&quot;Leave the version attribute unset when &quot;</span>
                        <span class="s2">&quot;merging to update the most recent version.&quot;</span>
                        <span class="o">%</span> <span class="p">(</span>
                            <span class="n">existing_version</span><span class="p">,</span>
                            <span class="n">state_str</span><span class="p">(</span><span class="n">merged_state</span><span class="p">),</span>
                            <span class="n">merged_version</span>
                        <span class="p">))</span>

            <span class="n">merged_state</span><span class="o">.</span><span class="n">load_path</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">load_path</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">load_options</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">load_options</span>

            <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">mapper</span><span class="o">.</span><span class="n">iterate_properties</span><span class="p">:</span>
                <span class="n">prop</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">state_dict</span><span class="p">,</span>
                           <span class="n">merged_state</span><span class="p">,</span> <span class="n">merged_dict</span><span class="p">,</span>
                           <span class="n">load</span><span class="p">,</span> <span class="n">_recursive</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">load</span><span class="p">:</span>
            <span class="c1"># remove any history</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">_commit_all</span><span class="p">(</span><span class="n">merged_dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">new_instance</span><span class="p">:</span>
            <span class="n">merged_state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">merged_state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">merged</span>

    <span class="k">def</span> <span class="nf">_validate_persistent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Instance &#39;</span><span class="si">%s</span><span class="s2">&#39; is not persistent within this Session&quot;</span> <span class="o">%</span>
                <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_save_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Object &#39;</span><span class="si">%s</span><span class="s2">&#39; already has an identity - &quot;</span>
                <span class="s2">&quot;it can&#39;t be registered as pending&quot;</span> <span class="o">%</span> <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_before_attach</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>
            <span class="n">state</span><span class="o">.</span><span class="n">insert_order</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attach</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">discard_existing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Instance &#39;</span><span class="si">%s</span><span class="s2">&#39; is not persisted&quot;</span> <span class="o">%</span>
                <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">deleted</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Instance &#39;</span><span class="si">%s</span><span class="s2">&#39; has been deleted.  Use the make_transient() &quot;</span>
                <span class="s2">&quot;function to send this object back to the transient state.&quot;</span> <span class="o">%</span>
                <span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_before_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">check_identity_map</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">discard_existing</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attach</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_save_or_update_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_impl</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_impl</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_delete_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">include_before</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">[</span><span class="n">state</span><span class="p">]</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">enable_relationship_loading</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Associate an object with this :class:`.Session` for related</span>
<span class="sd">        object loading.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            :meth:`.enable_relationship_loading` exists to serve special</span>
<span class="sd">            use cases and is not recommended for general use.</span>

<span class="sd">        Accesses of attributes mapped with :func:`.relationship`</span>
<span class="sd">        will attempt to load a value from the database using this</span>
<span class="sd">        :class:`.Session` as the source of connectivity.  The values</span>
<span class="sd">        will be loaded based on foreign key values present on this</span>
<span class="sd">        object - it follows that this functionality</span>
<span class="sd">        generally only works for many-to-one-relationships.</span>

<span class="sd">        The object will be attached to this session, but will</span>
<span class="sd">        **not** participate in any persistence operations; its state</span>
<span class="sd">        for almost all purposes will remain either &quot;transient&quot; or</span>
<span class="sd">        &quot;detached&quot;, except for the case of relationship loading.</span>

<span class="sd">        Also note that backrefs will often not work as expected.</span>
<span class="sd">        Altering a relationship-bound attribute on the target object</span>
<span class="sd">        may not fire off a backref event, if the effective value</span>
<span class="sd">        is what was already loaded from a foreign-key-holding value.</span>

<span class="sd">        The :meth:`.Session.enable_relationship_loading` method is</span>
<span class="sd">        similar to the ``load_on_pending`` flag on :func:`.relationship`.</span>
<span class="sd">        Unlike that flag, :meth:`.Session.enable_relationship_loading` allows</span>
<span class="sd">        an object to remain transient while still being able to load</span>
<span class="sd">        related items.</span>

<span class="sd">        To make a transient object associated with a :class:`.Session`</span>
<span class="sd">        via :meth:`.Session.enable_relationship_loading` pending, add</span>
<span class="sd">        it to the :class:`.Session` using :meth:`.Session.add` normally.</span>

<span class="sd">        :meth:`.Session.enable_relationship_loading` does not improve</span>
<span class="sd">        behavior when the ORM is used normally - object references should be</span>
<span class="sd">        constructed at the object level, not at the foreign key level, so</span>
<span class="sd">        that they are present in an ordinary way before flush()</span>
<span class="sd">        proceeds.  This method is not intended for general use.</span>

<span class="sd">        .. versionadded:: 0.8</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            ``load_on_pending`` at :func:`.relationship` - this flag</span>
<span class="sd">            allows per-relationship loading of many-to-ones on items that</span>
<span class="sd">            are pending.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attach</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">include_before</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">state</span><span class="o">.</span><span class="n">_load_pending</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_before_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">check_identity_map</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span> <span class="ow">and</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_attach</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">check_identity_map</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">and</span> \
            <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span> <span class="ow">and</span> \
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Can&#39;t attach instance &quot;</span>
                <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">; another instance with key </span><span class="si">%s</span><span class="s2"> is already &quot;</span>
                <span class="s2">&quot;present in this session.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">),</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">and</span> \
                <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span> <span class="ow">and</span> \
                <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">in</span> <span class="n">_sessions</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
                <span class="s2">&quot;Object &#39;</span><span class="si">%s</span><span class="s2">&#39; is already attached to session &#39;</span><span class="si">%s</span><span class="s2">&#39; &quot;</span>
                <span class="s2">&quot;(this is &#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">state_str</span><span class="p">(</span><span class="n">state</span><span class="p">),</span>
                                    <span class="n">state</span><span class="o">.</span><span class="n">session_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">include_before</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">include_before</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_before_attach</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hash_key</span>
            <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">modified</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">_strong_obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">state</span><span class="o">.</span><span class="n">_strong_obj</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_attach</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return True if the instance is associated with this session.</span>

<span class="sd">        The instance may be pending or persistent within the Session for a</span>
<span class="sd">        result of True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Iterate over all pending or persistent instances within this</span>
<span class="sd">        Session.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">_contains_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">contains_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objects</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Flush all the object changes to the database.</span>

<span class="sd">        Writes out all pending object creations, deletions and modifications</span>
<span class="sd">        to the database as INSERTs, DELETEs, UPDATEs, etc.  Operations are</span>
<span class="sd">        automatically ordered by the Session&#39;s unit of work dependency</span>
<span class="sd">        solver.</span>

<span class="sd">        Database operations will be issued in the current transactional</span>
<span class="sd">        context and do not affect the state of the transaction, unless an</span>
<span class="sd">        error occurs, in which case the entire transaction is rolled back.</span>
<span class="sd">        You may flush() as often as you like within a transaction to move</span>
<span class="sd">        changes from Python to the database&#39;s transaction buffer.</span>

<span class="sd">        For ``autocommit`` Sessions with no active manual transaction, flush()</span>
<span class="sd">        will create a transaction on the fly that surrounds the entire set of</span>
<span class="sd">        operations int the flush.</span>

<span class="sd">        :param objects: Optional; restricts the flush operation to operate</span>
<span class="sd">          only on elements that are in the given collection.</span>

<span class="sd">          This feature is for an extremely narrow set of use cases where</span>
<span class="sd">          particular objects may need to be operated upon before the</span>
<span class="sd">          full flush() occurs.  It is not intended for general use.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span><span class="s2">&quot;Session is already flushing&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_clean</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flush</span><span class="p">(</span><span class="n">objects</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_flush_warning</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;Usage of the &#39;</span><span class="si">%s</span><span class="s2">&#39; operation is not currently supported &quot;</span>
            <span class="s2">&quot;within the execution stage of the flush process. &quot;</span>
            <span class="s2">&quot;Results may not be consistent.  Consider using alternative &quot;</span>
            <span class="s2">&quot;event listeners or connection-level operations instead.&quot;</span>
            <span class="o">%</span> <span class="n">method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_is_clean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">check_modified</span><span class="p">()</span> <span class="ow">and</span> \
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">and</span> \
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span>

    <span class="k">def</span> <span class="nf">_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objects</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="n">dirty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty_states</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dirty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">return</span>

        <span class="n">flush_context</span> <span class="o">=</span> <span class="n">UOWTransaction</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_flush</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">before_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">,</span> <span class="n">objects</span><span class="p">)</span>
            <span class="c1"># re-establish &quot;dirty states&quot; in case the listeners</span>
            <span class="c1"># added</span>
            <span class="n">dirty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty_states</span>

        <span class="n">deleted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">)</span>

        <span class="n">dirty</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dirty</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">deleted</span><span class="p">)</span>

        <span class="c1"># create the set of all objects we want to operate upon</span>
        <span class="k">if</span> <span class="n">objects</span><span class="p">:</span>
            <span class="c1"># specific list passed in</span>
            <span class="n">objset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                <span class="n">objset</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">objset</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># store objects whose fate has been decided</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># put all saves/updates into the flush context.  detect top-level</span>
        <span class="c1"># orphans and throw them into deleted.</span>
        <span class="k">if</span> <span class="n">objset</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">dirty</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">objset</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">deleted</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">dirty</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">deleted</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">proc</span><span class="p">:</span>
            <span class="n">is_orphan</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">_state_mapper</span><span class="p">(</span><span class="n">state</span><span class="p">)</span><span class="o">.</span><span class="n">_is_orphan</span><span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">has_identity</span><span class="p">)</span>
            <span class="n">flush_context</span><span class="o">.</span><span class="n">register_object</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">isdelete</span><span class="o">=</span><span class="n">is_orphan</span><span class="p">)</span>
            <span class="n">processed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

        <span class="c1"># put all remaining deletes into the flush context.</span>
        <span class="k">if</span> <span class="n">objset</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">deleted</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">objset</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">proc</span> <span class="o">=</span> <span class="n">deleted</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">proc</span><span class="p">:</span>
            <span class="n">flush_context</span><span class="o">.</span><span class="n">register_object</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">isdelete</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">flush_context</span><span class="o">.</span><span class="n">has_work</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">flush_context</span><span class="o">.</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">transaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span>
            <span class="n">subtransactions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">flush_context</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_warn_on_events</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_flush</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">)</span>

            <span class="n">flush_context</span><span class="o">.</span><span class="n">finalize_flush_changes</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">objects</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">:</span>
                <span class="n">len_</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">)</span>

                <span class="n">statelib</span><span class="o">.</span><span class="n">InstanceState</span><span class="o">.</span><span class="n">_commit_all_states</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_modified</span><span class="p">],</span>
                    <span class="n">instance_dict</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="p">)</span>
                <span class="n">util</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Attribute history events accumulated on </span><span class="si">%d</span><span class="s2"> &quot;</span>
                          <span class="s2">&quot;previously clean instances &quot;</span>
                          <span class="s2">&quot;within inner-flush event handlers have been &quot;</span>
                          <span class="s2">&quot;reset, and will not result in database updates. &quot;</span>
                          <span class="s2">&quot;Consider using set_committed_value() within &quot;</span>
                          <span class="s2">&quot;inner-flush event handlers to avoid this warning.&quot;</span>
                          <span class="o">%</span> <span class="n">len_</span><span class="p">)</span>

            <span class="c1"># useful assertions:</span>
            <span class="c1"># if not objects:</span>
            <span class="c1">#    assert not self.identity_map._modified</span>
            <span class="c1"># else:</span>
            <span class="c1">#    assert self.identity_map._modified == \</span>
            <span class="c1">#            self.identity_map._modified.difference(objects)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="o">.</span><span class="n">after_flush_postexec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flush_context</span><span class="p">)</span>

            <span class="n">transaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                <span class="n">transaction</span><span class="o">.</span><span class="n">rollback</span><span class="p">(</span><span class="n">_capture_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bulk_save_objects</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">objects</span><span class="p">,</span> <span class="n">return_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">update_changed_only</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a bulk save of the given list of objects.</span>

<span class="sd">        The bulk save feature allows mapped objects to be used as the</span>
<span class="sd">        source of simple INSERT and UPDATE operations which can be more easily</span>
<span class="sd">        grouped together into higher performing &quot;executemany&quot;</span>
<span class="sd">        operations; the extraction of data from the objects is also performed</span>
<span class="sd">        using a lower-latency process that ignores whether or not attributes</span>
<span class="sd">        have actually been modified in the case of UPDATEs, and also ignores</span>
<span class="sd">        SQL expressions.</span>

<span class="sd">        The objects as given are not added to the session and no additional</span>
<span class="sd">        state is established on them, unless the ``return_defaults`` flag</span>
<span class="sd">        is also set, in which case primary key attributes and server-side</span>
<span class="sd">        default values will be populated.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The bulk save feature allows for a lower-latency INSERT/UPDATE</span>
<span class="sd">            of rows at the expense of most other unit-of-work features.</span>
<span class="sd">            Features such as object management, relationship handling,</span>
<span class="sd">            and SQL clause support are **silently omitted** in favor of raw</span>
<span class="sd">            INSERT/UPDATES of records.</span>

<span class="sd">            **Please read the list of caveats at** :ref:`bulk_operations`</span>
<span class="sd">            **before using this method, and fully test and confirm the</span>
<span class="sd">            functionality of all code developed using these systems.**</span>

<span class="sd">        :param objects: a list of mapped object instances.  The mapped</span>
<span class="sd">         objects are persisted as is, and are **not** associated with the</span>
<span class="sd">         :class:`.Session` afterwards.</span>

<span class="sd">         For each object, whether the object is sent as an INSERT or an</span>
<span class="sd">         UPDATE is dependent on the same rules used by the :class:`.Session`</span>
<span class="sd">         in traditional operation; if the object has the</span>
<span class="sd">         :attr:`.InstanceState.key`</span>
<span class="sd">         attribute set, then the object is assumed to be &quot;detached&quot; and</span>
<span class="sd">         will result in an UPDATE.  Otherwise, an INSERT is used.</span>

<span class="sd">         In the case of an UPDATE, statements are grouped based on which</span>
<span class="sd">         attributes have changed, and are thus to be the subject of each</span>
<span class="sd">         SET clause.  If ``update_changed_only`` is False, then all</span>
<span class="sd">         attributes present within each object are applied to the UPDATE</span>
<span class="sd">         statement, which may help in allowing the statements to be grouped</span>
<span class="sd">         together into a larger executemany(), and will also reduce the</span>
<span class="sd">         overhead of checking history on attributes.</span>

<span class="sd">        :param return_defaults: when True, rows that are missing values which</span>
<span class="sd">         generate defaults, namely integer primary key defaults and sequences,</span>
<span class="sd">         will be inserted **one at a time**, so that the primary key value</span>
<span class="sd">         is available.  In particular this will allow joined-inheritance</span>
<span class="sd">         and other multi-table mappings to insert correctly without the need</span>
<span class="sd">         to provide primary key values ahead of time; however,</span>
<span class="sd">         :paramref:`.Session.bulk_save_objects.return_defaults` **greatly</span>
<span class="sd">         reduces the performance gains** of the method overall.</span>

<span class="sd">        :param update_changed_only: when True, UPDATE statements are rendered</span>
<span class="sd">         based on those attributes in each state that have logged changes.</span>
<span class="sd">         When False, all attributes present are rendered into the SET clause</span>
<span class="sd">         with the exception of primary key attributes.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`bulk_operations`</span>

<span class="sd">            :meth:`.Session.bulk_insert_mappings`</span>

<span class="sd">            :meth:`.Session.bulk_update_mappings`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">isupdate</span><span class="p">),</span> <span class="n">states</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span>
            <span class="p">(</span><span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">),</span>
            <span class="k">lambda</span> <span class="n">state</span><span class="p">:</span> <span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">mapper</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bulk_save_mappings</span><span class="p">(</span>
                <span class="n">mapper</span><span class="p">,</span> <span class="n">states</span><span class="p">,</span> <span class="n">isupdate</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span>
                <span class="n">return_defaults</span><span class="p">,</span> <span class="n">update_changed_only</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bulk_insert_mappings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">mappings</span><span class="p">,</span> <span class="n">return_defaults</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a bulk insert of the given list of mapping dictionaries.</span>

<span class="sd">        The bulk insert feature allows plain Python dictionaries to be used as</span>
<span class="sd">        the source of simple INSERT operations which can be more easily</span>
<span class="sd">        grouped together into higher performing &quot;executemany&quot;</span>
<span class="sd">        operations.  Using dictionaries, there is no &quot;history&quot; or session</span>
<span class="sd">        state management features in use, reducing latency when inserting</span>
<span class="sd">        large numbers of simple rows.</span>

<span class="sd">        The values within the dictionaries as given are typically passed</span>
<span class="sd">        without modification into Core :meth:`.Insert` constructs, after</span>
<span class="sd">        organizing the values within them across the tables to which</span>
<span class="sd">        the given mapper is mapped.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The bulk insert feature allows for a lower-latency INSERT</span>
<span class="sd">            of rows at the expense of most other unit-of-work features.</span>
<span class="sd">            Features such as object management, relationship handling,</span>
<span class="sd">            and SQL clause support are **silently omitted** in favor of raw</span>
<span class="sd">            INSERT of records.</span>

<span class="sd">            **Please read the list of caveats at** :ref:`bulk_operations`</span>
<span class="sd">            **before using this method, and fully test and confirm the</span>
<span class="sd">            functionality of all code developed using these systems.**</span>

<span class="sd">        :param mapper: a mapped class, or the actual :class:`.Mapper` object,</span>
<span class="sd">         representing the single kind of object represented within the mapping</span>
<span class="sd">         list.</span>

<span class="sd">        :param mappings: a list of dictionaries, each one containing the state</span>
<span class="sd">         of the mapped row to be inserted, in terms of the attribute names</span>
<span class="sd">         on the mapped class.   If the mapping refers to multiple tables,</span>
<span class="sd">         such as a joined-inheritance mapping, each dictionary must contain</span>
<span class="sd">         all keys to be populated into all tables.</span>

<span class="sd">        :param return_defaults: when True, rows that are missing values which</span>
<span class="sd">         generate defaults, namely integer primary key defaults and sequences,</span>
<span class="sd">         will be inserted **one at a time**, so that the primary key value</span>
<span class="sd">         is available.  In particular this will allow joined-inheritance</span>
<span class="sd">         and other multi-table mappings to insert correctly without the need</span>
<span class="sd">         to provide primary</span>
<span class="sd">         key values ahead of time; however,</span>
<span class="sd">         :paramref:`.Session.bulk_insert_mappings.return_defaults`</span>
<span class="sd">         **greatly reduces the performance gains** of the method overall.</span>
<span class="sd">         If the rows</span>
<span class="sd">         to be inserted only refer to a single table, then there is no</span>
<span class="sd">         reason this flag should be set as the returned default information</span>
<span class="sd">         is not used.</span>


<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`bulk_operations`</span>

<span class="sd">            :meth:`.Session.bulk_save_objects`</span>

<span class="sd">            :meth:`.Session.bulk_update_mappings`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bulk_save_mappings</span><span class="p">(</span>
            <span class="n">mapper</span><span class="p">,</span> <span class="n">mappings</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">return_defaults</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">bulk_update_mappings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">mappings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform a bulk update of the given list of mapping dictionaries.</span>

<span class="sd">        The bulk update feature allows plain Python dictionaries to be used as</span>
<span class="sd">        the source of simple UPDATE operations which can be more easily</span>
<span class="sd">        grouped together into higher performing &quot;executemany&quot;</span>
<span class="sd">        operations.  Using dictionaries, there is no &quot;history&quot; or session</span>
<span class="sd">        state management features in use, reducing latency when updating</span>
<span class="sd">        large numbers of simple rows.</span>

<span class="sd">        .. versionadded:: 1.0.0</span>

<span class="sd">        .. warning::</span>

<span class="sd">            The bulk update feature allows for a lower-latency UPDATE</span>
<span class="sd">            of rows at the expense of most other unit-of-work features.</span>
<span class="sd">            Features such as object management, relationship handling,</span>
<span class="sd">            and SQL clause support are **silently omitted** in favor of raw</span>
<span class="sd">            UPDATES of records.</span>

<span class="sd">            **Please read the list of caveats at** :ref:`bulk_operations`</span>
<span class="sd">            **before using this method, and fully test and confirm the</span>
<span class="sd">            functionality of all code developed using these systems.**</span>

<span class="sd">        :param mapper: a mapped class, or the actual :class:`.Mapper` object,</span>
<span class="sd">         representing the single kind of object represented within the mapping</span>
<span class="sd">         list.</span>

<span class="sd">        :param mappings: a list of dictionaries, each one containing the state</span>
<span class="sd">         of the mapped row to be updated, in terms of the attribute names</span>
<span class="sd">         on the mapped class.   If the mapping refers to multiple tables,</span>
<span class="sd">         such as a joined-inheritance mapping, each dictionary may contain</span>
<span class="sd">         keys corresponding to all tables.   All those keys which are present</span>
<span class="sd">         and are not part of the primary key are applied to the SET clause</span>
<span class="sd">         of the UPDATE statement; the primary key values, which are required,</span>
<span class="sd">         are applied to the WHERE clause.</span>


<span class="sd">        .. seealso::</span>

<span class="sd">            :ref:`bulk_operations`</span>

<span class="sd">            :meth:`.Session.bulk_insert_mappings`</span>

<span class="sd">            :meth:`.Session.bulk_save_objects`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bulk_save_mappings</span><span class="p">(</span><span class="n">mapper</span><span class="p">,</span> <span class="n">mappings</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bulk_save_mappings</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">mappings</span><span class="p">,</span> <span class="n">isupdate</span><span class="p">,</span> <span class="n">isstates</span><span class="p">,</span>
            <span class="n">return_defaults</span><span class="p">,</span> <span class="n">update_changed_only</span><span class="p">):</span>
        <span class="n">mapper</span> <span class="o">=</span> <span class="n">_class_to_mapper</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">transaction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">begin</span><span class="p">(</span>
            <span class="n">subtransactions</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isupdate</span><span class="p">:</span>
                <span class="n">persistence</span><span class="o">.</span><span class="n">_bulk_update</span><span class="p">(</span>
                    <span class="n">mapper</span><span class="p">,</span> <span class="n">mappings</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span>
                    <span class="n">isstates</span><span class="p">,</span> <span class="n">update_changed_only</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">persistence</span><span class="o">.</span><span class="n">_bulk_insert</span><span class="p">(</span>
                    <span class="n">mapper</span><span class="p">,</span> <span class="n">mappings</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">isstates</span><span class="p">,</span> <span class="n">return_defaults</span><span class="p">)</span>
            <span class="n">transaction</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>

        <span class="k">except</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">util</span><span class="o">.</span><span class="n">safe_reraise</span><span class="p">():</span>
                <span class="n">transaction</span><span class="o">.</span><span class="n">rollback</span><span class="p">(</span><span class="n">_capture_exception</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_flushing</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">is_modified</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">include_collections</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">passive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return ``True`` if the given instance has locally</span>
<span class="sd">        modified attributes.</span>

<span class="sd">        This method retrieves the history for each instrumented</span>
<span class="sd">        attribute on the instance and performs a comparison of the current</span>
<span class="sd">        value to its previously committed value, if any.</span>

<span class="sd">        It is in effect a more expensive and accurate</span>
<span class="sd">        version of checking for the given instance in the</span>
<span class="sd">        :attr:`.Session.dirty` collection; a full test for</span>
<span class="sd">        each attribute&#39;s net &quot;dirty&quot; status is performed.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            return session.is_modified(someobject)</span>

<span class="sd">        .. versionchanged:: 0.8</span>
<span class="sd">            When using SQLAlchemy 0.7 and earlier, the ``passive``</span>
<span class="sd">            flag should **always** be explicitly set to ``True``,</span>
<span class="sd">            else SQL loads/autoflushes may proceed which can affect</span>
<span class="sd">            the modified state itself:</span>
<span class="sd">            ``session.is_modified(someobject, passive=True)``\ .</span>
<span class="sd">            In 0.8 and above, the behavior is corrected and</span>
<span class="sd">            this flag is ignored.</span>

<span class="sd">        A few caveats to this method apply:</span>

<span class="sd">        * Instances present in the :attr:`.Session.dirty` collection may</span>
<span class="sd">          report ``False`` when tested with this method.  This is because</span>
<span class="sd">          the object may have received change events via attribute mutation,</span>
<span class="sd">          thus placing it in :attr:`.Session.dirty`, but ultimately the state</span>
<span class="sd">          is the same as that loaded from the database, resulting in no net</span>
<span class="sd">          change here.</span>
<span class="sd">        * Scalar attributes may not have recorded the previously set</span>
<span class="sd">          value when a new value was applied, if the attribute was not loaded,</span>
<span class="sd">          or was expired, at the time the new value was received - in these</span>
<span class="sd">          cases, the attribute is assumed to have a change, even if there is</span>
<span class="sd">          ultimately no net change against its database value. SQLAlchemy in</span>
<span class="sd">          most cases does not need the &quot;old&quot; value when a set event occurs, so</span>
<span class="sd">          it skips the expense of a SQL call if the old value isn&#39;t present,</span>
<span class="sd">          based on the assumption that an UPDATE of the scalar value is</span>
<span class="sd">          usually needed, and in those few cases where it isn&#39;t, is less</span>
<span class="sd">          expensive on average than issuing a defensive SELECT.</span>

<span class="sd">          The &quot;old&quot; value is fetched unconditionally upon set only if the</span>
<span class="sd">          attribute container has the ``active_history`` flag set to ``True``.</span>
<span class="sd">          This flag is set typically for primary key attributes and scalar</span>
<span class="sd">          object references that are not a simple many-to-one.  To set this</span>
<span class="sd">          flag for any arbitrary mapped column, use the ``active_history``</span>
<span class="sd">          argument with :func:`.column_property`.</span>

<span class="sd">        :param instance: mapped instance to be tested for pending changes.</span>
<span class="sd">        :param include_collections: Indicates if multivalued collections</span>
<span class="sd">         should be included in the operation.  Setting this to ``False`` is a</span>
<span class="sd">         way to detect only local-column based properties (i.e. scalar columns</span>
<span class="sd">         or many-to-one foreign keys) that would result in an UPDATE for this</span>
<span class="sd">         instance upon flush.</span>
<span class="sd">        :param passive:</span>
<span class="sd">         .. versionchanged:: 0.8</span>
<span class="sd">             Ignored for backwards compatibility.</span>
<span class="sd">             When using SQLAlchemy 0.7 and earlier, this flag should always</span>
<span class="sd">             be set to ``True``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">object_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">state</span><span class="o">.</span><span class="n">modified</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">dict_</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">dict</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">manager</span><span class="o">.</span><span class="n">attributes</span><span class="p">:</span>
            <span class="k">if</span> \
                    <span class="p">(</span>
                        <span class="ow">not</span> <span class="n">include_collections</span> <span class="ow">and</span>
                        <span class="nb">hasattr</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span> <span class="s1">&#39;get_collection&#39;</span><span class="p">)</span>
                    <span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">attr</span><span class="o">.</span><span class="n">impl</span><span class="p">,</span> <span class="s1">&#39;get_history&#39;</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="p">(</span><span class="n">added</span><span class="p">,</span> <span class="n">unchanged</span><span class="p">,</span> <span class="n">deleted</span><span class="p">)</span> <span class="o">=</span> \
                <span class="n">attr</span><span class="o">.</span><span class="n">impl</span><span class="o">.</span><span class="n">get_history</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">dict_</span><span class="p">,</span>
                                      <span class="n">passive</span><span class="o">=</span><span class="n">attributes</span><span class="o">.</span><span class="n">NO_CHANGE</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">added</span> <span class="ow">or</span> <span class="n">deleted</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_active</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;True if this :class:`.Session` is in &quot;transaction mode&quot; and</span>
<span class="sd">        is not in &quot;partial rollback&quot; state.</span>

<span class="sd">        The :class:`.Session` in its default mode of ``autocommit=False``</span>
<span class="sd">        is essentially always in &quot;transaction mode&quot;, in that a</span>
<span class="sd">        :class:`.SessionTransaction` is associated with it as soon as</span>
<span class="sd">        it is instantiated.  This :class:`.SessionTransaction` is immediately</span>
<span class="sd">        replaced with a new one as soon as it is ended, due to a rollback,</span>
<span class="sd">        commit, or close operation.</span>

<span class="sd">        &quot;Transaction mode&quot; does *not* indicate whether</span>
<span class="sd">        or not actual database connection resources are in use;  the</span>
<span class="sd">        :class:`.SessionTransaction` object coordinates among zero or more</span>
<span class="sd">        actual database transactions, and starts out with none, accumulating</span>
<span class="sd">        individual DBAPI connections as different data sources are used</span>
<span class="sd">        within its scope.   The best way to track when a particular</span>
<span class="sd">        :class:`.Session` has actually begun to use DBAPI resources is to</span>
<span class="sd">        implement a listener using the :meth:`.SessionEvents.after_begin`</span>
<span class="sd">        method, which will deliver both the :class:`.Session` as well as the</span>
<span class="sd">        target :class:`.Connection` to a user-defined event listener.</span>

<span class="sd">        The &quot;partial rollback&quot; state refers to when an &quot;inner&quot; transaction,</span>
<span class="sd">        typically used during a flush, encounters an error and emits a</span>
<span class="sd">        rollback of the DBAPI connection.  At this point, the</span>
<span class="sd">        :class:`.Session` is in &quot;partial rollback&quot; and awaits for the user to</span>
<span class="sd">        call :meth:`.Session.rollback`, in order to close out the</span>
<span class="sd">        transaction stack.  It is in this &quot;partial rollback&quot; period that the</span>
<span class="sd">        :attr:`.is_active` flag returns False.  After the call to</span>
<span class="sd">        :meth:`.Session.rollback`, the :class:`.SessionTransaction` is</span>
<span class="sd">        replaced with a new one and :attr:`.is_active` returns ``True`` again.</span>

<span class="sd">        When a :class:`.Session` is used in ``autocommit=True`` mode, the</span>
<span class="sd">        :class:`.SessionTransaction` is only instantiated within the scope</span>
<span class="sd">        of a flush call, or when :meth:`.Session.begin` is called.  So</span>
<span class="sd">        :attr:`.is_active` will always be ``False`` outside of a flush or</span>
<span class="sd">        :meth:`.Session.begin` block in this mode, and will be ``True``</span>
<span class="sd">        within the :meth:`.Session.begin` block as long as it doesn&#39;t enter</span>
<span class="sd">        &quot;partial rollback&quot; state.</span>

<span class="sd">        From all the above, it follows that the only purpose to this flag is</span>
<span class="sd">        for application frameworks that wish to detect is a &quot;rollback&quot; is</span>
<span class="sd">        necessary within a generic error handling routine, for</span>
<span class="sd">        :class:`.Session` objects that would otherwise be in</span>
<span class="sd">        &quot;partial rollback&quot; mode.  In a typical integration case, this is also</span>
<span class="sd">        not necessary as it is standard practice to emit</span>
<span class="sd">        :meth:`.Session.rollback` unconditionally within the outermost</span>
<span class="sd">        exception catch.</span>

<span class="sd">        To track the transactional state of a :class:`.Session` fully,</span>
<span class="sd">        use event listeners, primarily the :meth:`.SessionEvents.after_begin`,</span>
<span class="sd">        :meth:`.SessionEvents.after_commit`,</span>
<span class="sd">        :meth:`.SessionEvents.after_rollback` and related events.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">transaction</span><span class="o">.</span><span class="n">is_active</span>

    <span class="n">identity_map</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;A mapping of object identities to objects themselves.</span>

<span class="sd">    Iterating through ``Session.identity_map.values()`` provides</span>
<span class="sd">    access to the full set of persistent objects (i.e., those</span>
<span class="sd">    that have row identity) currently in the session.</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.identity_key` - helper function to produce the keys used</span>
<span class="sd">        in this dictionary.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_dirty_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The set of all persistent states considered dirty.</span>

<span class="sd">        This method returns all states that were modified including</span>
<span class="sd">        those that were possibly deleted.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">identity_map</span><span class="o">.</span><span class="n">_dirty_states</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The set of all persistent instances considered dirty.</span>

<span class="sd">        E.g.::</span>

<span class="sd">            some_mapped_object in session.dirty</span>

<span class="sd">        Instances are considered dirty when they were modified but not</span>
<span class="sd">        deleted.</span>

<span class="sd">        Note that this &#39;dirty&#39; calculation is &#39;optimistic&#39;; most</span>
<span class="sd">        attribute-setting or collection modification operations will</span>
<span class="sd">        mark an instance as &#39;dirty&#39; and place it in this set, even if</span>
<span class="sd">        there is no net change to the attribute&#39;s value.  At flush</span>
<span class="sd">        time, the value of each attribute is compared to its</span>
<span class="sd">        previously saved value, and if there&#39;s no net change, no SQL</span>
<span class="sd">        operation will occur (this is a more expensive operation so</span>
<span class="sd">        it&#39;s only done at flush time).</span>

<span class="sd">        To check if an instance has actionable net changes to its</span>
<span class="sd">        attributes, use the :meth:`.Session.is_modified` method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">IdentitySet</span><span class="p">(</span>
            <span class="p">[</span><span class="n">state</span><span class="o">.</span><span class="n">obj</span><span class="p">()</span>
             <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dirty_states</span>
             <span class="k">if</span> <span class="n">state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">deleted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;The set of all instances marked as &#39;deleted&#39; within this ``Session``&quot;</span>

        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">IdentitySet</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_deleted</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">new</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;The set of all instances marked as &#39;new&#39; within this ``Session``.&quot;</span>

        <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">IdentitySet</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>


<span class="k">class</span> <span class="nc">sessionmaker</span><span class="p">(</span><span class="n">_SessionClassMethods</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A configurable :class:`.Session` factory.</span>

<span class="sd">    The :class:`.sessionmaker` factory generates new</span>
<span class="sd">    :class:`.Session` objects when called, creating them given</span>
<span class="sd">    the configurational arguments established here.</span>

<span class="sd">    e.g.::</span>

<span class="sd">        # global scope</span>
<span class="sd">        Session = sessionmaker(autoflush=False)</span>

<span class="sd">        # later, in a local scope, create and use a session:</span>
<span class="sd">        sess = Session()</span>

<span class="sd">    Any keyword arguments sent to the constructor itself will override the</span>
<span class="sd">    &quot;configured&quot; keywords::</span>

<span class="sd">        Session = sessionmaker()</span>

<span class="sd">        # bind an individual session to a connection</span>
<span class="sd">        sess = Session(bind=connection)</span>

<span class="sd">    The class also includes a method :meth:`.configure`, which can</span>
<span class="sd">    be used to specify additional keyword arguments to the factory, which</span>
<span class="sd">    will take effect for subsequent :class:`.Session` objects generated.</span>
<span class="sd">    This is usually used to associate one or more :class:`.Engine` objects</span>
<span class="sd">    with an existing :class:`.sessionmaker` factory before it is first</span>
<span class="sd">    used::</span>

<span class="sd">        # application starts</span>
<span class="sd">        Session = sessionmaker()</span>

<span class="sd">        # ... later</span>
<span class="sd">        engine = create_engine(&#39;sqlite:///foo.db&#39;)</span>
<span class="sd">        Session.configure(bind=engine)</span>

<span class="sd">        sess = Session()</span>

<span class="sd">    .. seealso:</span>

<span class="sd">        :ref:`session_getting` - introductory text on creating</span>
<span class="sd">        sessions using :class:`.sessionmaker`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="n">Session</span><span class="p">,</span> <span class="n">autoflush</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">autocommit</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">expire_on_commit</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Construct a new :class:`.sessionmaker`.</span>

<span class="sd">        All arguments here except for ``class_`` correspond to arguments</span>
<span class="sd">        accepted by :class:`.Session` directly.  See the</span>
<span class="sd">        :meth:`.Session.__init__` docstring for more details on parameters.</span>

<span class="sd">        :param bind: a :class:`.Engine` or other :class:`.Connectable` with</span>
<span class="sd">         which newly created :class:`.Session` objects will be associated.</span>
<span class="sd">        :param class_: class to use in order to create new :class:`.Session`</span>
<span class="sd">         objects.  Defaults to :class:`.Session`.</span>
<span class="sd">        :param autoflush: The autoflush setting to use with newly created</span>
<span class="sd">         :class:`.Session` objects.</span>
<span class="sd">        :param autocommit: The autocommit setting to use with newly created</span>
<span class="sd">         :class:`.Session` objects.</span>
<span class="sd">        :param expire_on_commit=True: the expire_on_commit setting to use</span>
<span class="sd">         with newly created :class:`.Session` objects.</span>
<span class="sd">        :param info: optional dictionary of information that will be available</span>
<span class="sd">         via :attr:`.Session.info`.  Note this dictionary is *updated*, not</span>
<span class="sd">         replaced, when the ``info`` parameter is specified to the specific</span>
<span class="sd">         :class:`.Session` construction operation.</span>

<span class="sd">         .. versionadded:: 0.9.0</span>

<span class="sd">        :param \**kw: all other keyword arguments are passed to the</span>
<span class="sd">         constructor of newly created :class:`.Session` objects.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;bind&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bind</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;autoflush&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">autoflush</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;autocommit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">autocommit</span>
        <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;expire_on_commit&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expire_on_commit</span>
        <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span> <span class="o">=</span> <span class="n">kw</span>
        <span class="c1"># make our own subclass of the given class, so that</span>
        <span class="c1"># events can be associated with it specifically.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">class_</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="p">(</span><span class="n">class_</span><span class="p">,),</span> <span class="p">{})</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">local_kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Produce a new :class:`.Session` object using the configuration</span>
<span class="sd">        established in this :class:`.sessionmaker`.</span>

<span class="sd">        In Python, the ``__call__`` method is invoked on an object when</span>
<span class="sd">        it is &quot;called&quot; in the same way as a function::</span>

<span class="sd">            Session = sessionmaker()</span>
<span class="sd">            session = Session()  # invokes sessionmaker.__call__()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;info&#39;</span> <span class="ow">and</span> <span class="s1">&#39;info&#39;</span> <span class="ow">in</span> <span class="n">local_kw</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">d</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">local_kw</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">])</span>
                <span class="n">local_kw</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">local_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_</span><span class="p">(</span><span class="o">**</span><span class="n">local_kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;(Re)configure the arguments for this sessionmaker.</span>

<span class="sd">        e.g.::</span>

<span class="sd">            Session = sessionmaker()</span>

<span class="sd">            Session.configure(bind=create_engine(&#39;sqlite://&#39;))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">new_kw</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">(class_=</span><span class="si">%r</span><span class="s2">,</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">class_</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
            <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">=</span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">kw</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="p">)</span>


<span class="k">def</span> <span class="nf">make_transient</span><span class="p">(</span><span class="n">instance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make the given instance &#39;transient&#39;.</span>

<span class="sd">    This will remove its association with any</span>
<span class="sd">    session and additionally will remove its &quot;identity key&quot;,</span>
<span class="sd">    such that it&#39;s as though the object were newly constructed,</span>
<span class="sd">    except retaining its values.   It also resets the</span>
<span class="sd">    &quot;deleted&quot; flag on the state if this object</span>
<span class="sd">    had been explicitly deleted by its session.</span>

<span class="sd">    Attributes which were &quot;expired&quot; or deferred at the</span>
<span class="sd">    instance level are reverted to undefined, and</span>
<span class="sd">    will not trigger any loads.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">_state_session</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">_expunge_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>

    <span class="c1"># remove expired state</span>
    <span class="n">state</span><span class="o">.</span><span class="n">expired_attributes</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="c1"># remove deferred callables</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">callables</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">callables</span>

    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">deleted</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">deleted</span>


<span class="k">def</span> <span class="nf">make_transient_to_detached</span><span class="p">(</span><span class="n">instance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make the given transient instance &#39;detached&#39;.</span>

<span class="sd">    All attribute history on the given instance</span>
<span class="sd">    will be reset as though the instance were freshly loaded</span>
<span class="sd">    from a query.  Missing attributes will be marked as expired.</span>
<span class="sd">    The primary key attributes of the object, which are required, will be made</span>
<span class="sd">    into the &quot;key&quot; of the instance.</span>

<span class="sd">    The object can then be added to a session, or merged</span>
<span class="sd">    possibly with the load=False flag, at which point it will look</span>
<span class="sd">    as if it were loaded that way, without emitting SQL.</span>

<span class="sd">    This is a special use case function that differs from a normal</span>
<span class="sd">    call to :meth:`.Session.merge` in that a given persistent state</span>
<span class="sd">    can be manufactured without any SQL calls.</span>

<span class="sd">    .. versionadded:: 0.9.5</span>

<span class="sd">    .. seealso::</span>

<span class="sd">        :func:`.make_transient`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">session_id</span> <span class="ow">or</span> <span class="n">state</span><span class="o">.</span><span class="n">key</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">sa_exc</span><span class="o">.</span><span class="n">InvalidRequestError</span><span class="p">(</span>
            <span class="s2">&quot;Given object must be transient&quot;</span><span class="p">)</span>
    <span class="n">state</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">mapper</span><span class="o">.</span><span class="n">_identity_key_from_state</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">deleted</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">state</span><span class="o">.</span><span class="n">deleted</span>
    <span class="n">state</span><span class="o">.</span><span class="n">_commit_all</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">)</span>
    <span class="n">state</span><span class="o">.</span><span class="n">_expire_attributes</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">dict</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">unloaded</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">object_session</span><span class="p">(</span><span class="n">instance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the :class:`.Session` to which the given instance belongs.</span>

<span class="sd">    This is essentially the same as the :attr:`.InstanceState.session`</span>
<span class="sd">    accessor.  See that attribute for details.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">attributes</span><span class="o">.</span><span class="n">instance_state</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">exc</span><span class="o">.</span><span class="n">NO_STATE</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">exc</span><span class="o">.</span><span class="n">UnmappedInstanceError</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_state_session</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>


<span class="n">_new_sessionid</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">counter</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Andreas Simbürger.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1.3.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>